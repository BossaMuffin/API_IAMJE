/ *! jQuery v2.0.3 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
// @ sourceMappingURL = jquery-2.0.3.min.map
* /
(fonction (e, indéfinie) {var t, n, r = type indéfini, i = emplacement.e, o = e.document, s = o objet.documentElement, a = e.jQuery, u = e. $, l = {}, c = [], p = "2.0.3", f = c.concat, h = c.push, d = c.slice, g = c.indexOf, m = l.toString, y = l. hasOwnProperty, v = p.trim, x = fonction (e, n) {retourne un nouveau x.fn.init (e, n, t)}, b = / [+ -]? (?: \ d * \. | ) \ d + (?: [eE] [+ -]? \ d + |) /. source, w = / \ S + / g, T = / ^ (?: \ s * (<[\ w \ W] +> ) [^>] * | # ([\ w -] *)) $ /, C = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, k = / ^ - ms - /, N = / - ([\ da-z]) / gi, E = fonction (e, t) {retour t.toUpperCase ()}, S = fonction () {o.removeEventListener ("DOMContentLoaded", S,! 1), e.removeEventListener ("load", S,! 1), x.ready ()}; x.fn = x.prototype = {jQuery: p, constructeur: x, init : fonction (e, t, n) {var r, i; if (! e) retourne ceci; if ("chaîne" == typeof e) {if (r = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3? [null, e, null]: T.exec (e),! r ||! r [1] && t) retourne! t || t.jquery? (t || n) .find (e): ce.constructeur (t) .find (e); if (r [1]) {if (t = t instance de x? t [0]: t, x.merge (this, x.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: o, ! 0)), C.test (r [1]) && x.isPlainObject (t)) pour (r dans t) x.isFunction (this [r])? This [r] (t [r]): this. attr (r, t [r]); renvoyer ceci} renvoyer i = o.getElementById (r [2]), i && i.parentNode && (this.length = 1, this [0] = i), this.context = o, this.selector = e, this} retourne e.nodeType? (this.context = this [0] = e, this.length = 1, this): x.isFunction (e)? n.ready (e) :( e .selector! == undefined && (this.selector = e.selector, this.context = e.context), x.makeArray (e, this))}, sélecteur: "", longueur: 0, toArray: function () { return d.call (this)}, get: function (e) {return null == e? this.toArray (): 0> e? this [this.length + e]: this [e]}, pushStack: function (e) {var t = x.merge (this.constructor (), e);return t.prevObject = this, t.context = this.context, t}, chacun: function (e, t) {return x.each (this, e, t)}, prêt: function (e) {return x. ready.promise (). done (e), this}, slice: function () {renvoie this.pushStack (d.apply (this, arguments))}, premier: function () {renvoie this.eq (0)} , last: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (0> e? t: 0); renvoie this.pushStack ( n> = 0 && t> n? [this [n]]: [])}, map: function (e) {return this.pushStack (x.map (this, function (t, n) {return e.call (t , n, t)}))}, fin: function () {retour this.prevObject || this.constructor (null)}, push: h, tri: []. sort, splice: []. splice}, x .fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {var, t, n, r, i, o, s = arguments [0] || {}, a = 1, u = arguments.length, l =! 1; pour ("booléen" == typeof s && (l = s, s = arguments [1] || {}, a = 2), "objet" == typeof s || x.isFunction (s) || (s = {}), u === a && (s = ceci,--a); u> a; a ++) si (null! = (e = arguments [a])) pour (t dans e) n = s [t], r = e [t], s! == r && (l && r && (x.isPlainObject (r) || (i = x.isArray (r)))? (i? (i =! 1, o = n && x.isArray (n)? n: []): o = n && x .isPlainObject (n)? n: {}, s [t] = x.extend (l, o, r)): r! == non défini && (s [t] = r)); retourne s}, x.extend ({expando: "jQuery" + (p + Math.random ()). replace (/ \ D / g, ""), noConflict: function (t) {retourne e. $ === x && (e. $ = u), t && e.jQuery === x && (e.jQuery = a), x}, isReady:! 1, readyWait: 1, holdReady: function (e) {e? x.readyWait ++: x.ready (! 0) }, prêt: fonction (e) {(e ===! 0? - x.readyWait: x.isReady) || (x.isReady =! 0, e! ==! 0 && - x.readyWait> 0 || (n.resolveWith (o, [x]), x.fn.trigger && x (o) .trigger ("ready"). off ("ready")))}, isFunction: function (e) {return "function "=== x.type (e)}, isArray: Array.isArray, isWindow:function (e) {return null! = e && e === e.window}, isNumeric: function (e) {return! isNaN (parseFloat (e)) && isFinite (e)}, tapez: function (e) {return null = = e? e + "": "objet" == typeof e || "fonction" == typeof e? l [m.call (e)] || "objet": typeof e}, isPlainObject: fonction (e) { if ("objet"! == x.type (e) || e.nodeType || x.isWindow (e)) renvoie! 1; essayez {if (e.constructor &&! y.call (e.constructor.prototype, "isPrototypeOf")) return! 1} catch (t) {return! 1} return! 0}, isEmptyObject: function (e) {var t; pour (t dans e) return! 1; return! 0}, erreur: fonction (e) {erreur de calcul (e)}, parseHTML: fonction (e, t, n) {si (! e || "chaîne"! = typede e) retourne null; "boolean" == typede t && (n = t, t =! 1), t = t || o; var r = C.exec (e), i =! n && []; retourne r? [t.createElement (r [1])] :( r = x.buildFragment ([e], t, i), i && x (i) .remove (), x.merge ([], r.childNodes))}}, parseJSON: JSON.parse, parseXML: fonction (e) {variable, n; si (! e || "chaîne"! = typeof e) retourne null; essai {n = nouveau DOMParser, t = n .parseFromString (e, "text / xml")} catch (r) {t = non défini} return (! t || t.| t.getElementsByTagName ("parsererror"). length) && x.error ("XML non valide:" + e) , t}, noop: fonction () {}, globalEval: fonction (e) {var t, n = eval; e = x.trim (e), e && (1 === e.indexOf ("use strict") ? (t = o.createElement ("script"), t.text = e, o.head.appendChild (t) .parentNode.removeChild (t)): n (e))}, camelCase: fonction (e) { renvoyer e.replace (k, "ms -"). remplacer (N, E)}, NomNoeud: function (e, t) {retourne e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, chacun: fonction (e, t, n) {varr, i = 0, o = e.longueur, s = j (e); si (n) {si (s) {pour (; o> i; i ++) si (r = t.apply (e [i], n), r ===! 1) rompt} sinon pour (i dans e) if (r = t.apply (e [i], n), r = ==!1) casser} sinon si (s) {pour (; o> i; i ++) si (r = appel.c (e [i], i, e [i]), r ===! 1) pause} autre pour (i dans e) si (r = t.call (e [i], i, e [i]), r ===! 1) coupure; retour e}, trim: fonction (e) {retour null = = e? "": v.call (e)}, makeArray: fonction (e, t) {var n = t || []; renvoie null! = e && (j (Object (e))?? x.merge ( n, "chaîne" == typede e? [e]: e): h.call (n, e)), n}, inArray: fonction (e, t, n) {retour null == t? -1: g.call (t, e, n)}, fusion: fonction (e, t) {var n = longueur t, r = longueur e, i = 0; if ("nombre" == type de n) pour ( ; n> i; i ++) e [r ++] = t [i]; sinon tandis que (t [i]! == indéfini) e [r ++] = t [i ++]; renvoyer e.length = r, e}, grep : fonction (e, t, n) {var r, i = [], o = 0, s = e.longueur; pour (n = !! n; s> o; o ++) r = !! t (e [ o], o), n! == r && i.push (e [o]); retour i}, carte: fonction (e, t, n) {varr, i = 0, o = e.longueur, s = j (e), a = []; si (s) pour (; o> i; i ++) r = t (e [i], i, n), null! = r && (a [longueur.aune] = r ); sinon pour (i dans e) r = t (e [i], i, n), null! = r && (a [a.longueur] = r); retourne f.apply ([], a)}, guid: 1, proxy: fonction (e, t) {var n, r, i; retourne "chaîne" == typede t && (n = e [t], t = e, e = n), x.isFonction (e)? (r = d.call (arguments, 2), i = fonction () {retourne e.apply (t || this, r. concat (d.call (arguments)))}, i.guid = e.guid = e.guid || x.guid ++, i): non défini}, accès: fonction (e, t, n, r, i, o) , s) {var a = 0, u = longueur e, l = null == n; si ("objet" === x.type (n)) {i =! 0; pour (a dans n) x .access (e, t, a, n [a],! 0, o, s)} sinon si (r! == indéfini && (i =! 0, x.isFunction (r) || (s =! 0) , l && (s? (t.call (e, r), t = null) :( l = t, t = fonction (e, t, n) {retourne l.call (x (e), n)}) ), t)) pour (; u> a; a ++) t (e [a], n, s? r: r.call (e [a], a, t (e [a], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, maintenant: Date.now, échange: fonction (e, t, n, r) {var i , o, s = {}; pour (o in t) s [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r || [ ]); pour (o in t) e.style [o] = s [o]; retourne i}}), x.ready.promise = fonction (t) {retourne n || (n = x.Deferred (), "complete" === o.readyState? SetTimeout (x.ready) :( o.addEventListener ("DOMContentLoaded", S,! 1), e.addEventListener ("charge", S,! 1)) ), n.promise (t)}, x.each ("Boolean Number String Function Tableau Date RegExp Object Error" .split (""), fonction (e, t) {l ["[objet" + t + "]" ] = t.toLowerCase ()}); fonction j (e) {var t = e.longueur, n = x.type (e); renvoyer x.isWindow (e)?! 1: 1 === e.nodeType && t ?! 0: "tableau" === n || "fonction"! == n && (0 === t || "numéro" == typede t && t> 0 && t-1 dans e)} t = x (o), fonction (e, indéfinie) {var t, n, r, i, o, s, a, u, l, c, p, f, h, d, g, m, y, v = "grésillement" + - nouveau Date, b = document e, w = 0, T = 0, C = st (), k = st (), N = st (), E =! 1, S = fonction (e, t) {retour e === t? (E =! 0,0): 0}, j = type non défini, D = 1 << 31, A = {}. hasOwnProperty, L = [], q = L.pop, H = L .push, O = L.push, F = L.slice,P = L.indexOf || fonction (e) {var t = 0, n = ceci.longueur; pour (; n> t; t ++) si (ce [t] === e) retourne t; retourne-1} , R = "vérifié | sélectionné | asynchrone | autofocus | lecture automatique | contrôles | différer | désactivé | caché | ismap | boucle | multiple | ouvert | en lecture seule | obligatoire | scoped", M = "[\\ x20 \\ t \\ r \\ n \\ f] ", W =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", $ = W.replace (" w "," w # "), B =" \\ ["+ M +" * ("+ W +") "+ M +" * (?: ([* ^ $ |! ~]? =) "+ M +" * (?: (['\ "]) ((?: \\\\. | [^ \\\\]] *?) \\ 3 | (" + $ + ") |) |)" + M + " * \\] ", I =" :( "" W + ") (?: \\ (((''" ")) ((?: \\\\. | [^ \\\\]) *? ) \\ 3 | ((?: \\\\. | [^ \\\\ () [\\]] | "+ B.replace (3,8) +") *) |. *) ) |) ", z = RegExp (" ^ "+ M +" + ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ ", "g"), _ = RegExp ("^" + M + "*," + M + "*"), X = RegExp ("^"+ M + "* ([> + ~] |" + M + ")" + M + "*"), U = RegExp (M + "* [+ ~]"), Y = RegExp ("=" + M + "* [^ \\] '\ "] *)" + M + "* \\]", "g"), V = RegExp (I), G = RegExp ("^" + $ + "$"), J = {ID: RegExp ("^ # (" + W + ")"), CLASSE: RegExp ("^ \\. (" + W + ")"), TAG: RegExp ("^ (" + W.replace ("w "," w * ") +") "), ATTR: RegExp (" ^ "+ B), PSEUDO: RegExp (" ^ "+ I), ENFANT: RegExp (" ^ :( seulement | premier | dernier | nième | nième-dernier) - (enfant | de type) (?: \\ ("+ M +" * (pair | impair) (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |), "i"), bool: RegExp ("^ (?: "+ R +") $ "," i "), needsContext: RegExp (" ^ "+ M +" * [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (? : \\ ("+ M +" * ((?:- \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Q = / ^ [^ {] + \ { \ s * \ [natif \ w /, K = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, Z = / ^ (?: input | select | textarea | button) $ / i, et = / ^ h \ d $ / i, tt = / '| \\ / g, nt = RegExp ("\\\\ ([\\ da -f] {1,6} "+ M +"? | ("+ M +") |.) "," ig "), rt = fonction (e, t, n) {var r =" 0x "+ t- 65536; return r! == r || n? T: 0> r? String.fromCharCode (r + 65536): String.fromCharCode (55296 | r >> 10,56320 | 1023 & r)}; essayez {O.apply ( L = F.call (b.childNodes), b.childNodes), L [b.childNodes.length] .nodeType} catch (it) {O = {apply: L.length? Function (e, t) {H. appliquer (e, F.call (t))}: fonction (e, t) {var n = longueur.e, r = 0; tandis que (e [n ++] = t [r ++]); e.longueur = n- 1}}} fonction ot (e, t, r, i) {var o, s, a, u, l, f, g, m, x, w; if ((t? T.ownerDocument || t: b )! == p && c (t), t = t || p, r = r || [],! e || "chaîne"! = typeof e) renvoie r; if (1! == (u = t. nodeType) && 9! == u) return [];si (h &&! i) {si (o = K.exec (e)) si (a = o [1]) {si (9 === u) {si (s = t.getElementById (a),! s ||! s.parentNode) return r; if (s.id === a) retourne r.push (s), r} else if (t.ownerDocument && (s = t.ownerDocument.getElementById (a)) && y ( t, s) && s.id === a) retourne r.push (s), r} sinon {if (o [2]) renvoie O.apply (r, t.getElementsByTagName (e)), r; if ( (a = o [3]) && n.getElementsByClassName && t.getElementsByClassName) renvoie O.apply (r, t.getElementsByClassName (a)), r} if (n.qsa && (! d ||! d.test (e))) {si (m = g = v, x = t, w = 9 === u && e, 1 === u && "objet"! == t.nodeName.toLowerCase ()) {f = gt (e), (g = t.getAttribute ("id"))? m = g.replace (tt, "\\ $ &"): t.setAttribute ("id", m), m = "[id = '" + m + "' ] ", l = f.length; tandis que (l -) f [l] = m + mt (f [l]); x = test.e (e) && t.parentNode || t, w = f.join (",")} if (w) try {return O.apply (r, x.querySelectorAll (w)), r} catch (T) {} enfin {g || t.removeAttribute ("id")}}} renvoie kt (e.replace (z, "$ 1"), t, r, i)} fonction st () {var e = []; fonction t (n, r) {retour e.push (n + = "")> i.cacheLength && supprimer t [e.shift ()], t [n] = r} retourne t} fonction en (e) {retour e [v] =! 0, e} fonction ut (e) {var t = p.createElement ("div"); essayez {retour !! e (t)} catch (n) {return! 1} finally {t.parentNode && t.parentNode.removeChild (t), t = null}} fonction lt (e, t) {var n = e.split ("|") , r = e.length; tandis que (r -) i.attrHandle [n [r]] = t} fonction ct (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~ t.sourceIndex || D) - (~ e.sourceIndex || D); if (r) renvoie r; if (n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} function pt (e) {return fonction (t) {var n = t.nodeNome.toLowerCase (); return "input" === n && t.type === e}} fonction ft (e) {return fonction (t) {var n = t.nodeNome.toLowerCase (); return ("input" === n || "bouton" === n) && t .type === e}} function ht (e) {retourne à (fonction (t) {retourne t = + t, à (fonction (n, r) {var i, o = e ([], n.longueur , t), s = longueur, tandis que (s -) n [i = o [s]] && (n [i] =! (r [i] = n [i])})})} s = ot.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; renvoyer t? "HTML"! == t.nodeNom:! 1}, n = ot.support = { }, c = ot.setDocument = fonction (e) {var t = e? possesseurDocument || e: b, r = t.defaultView; renvoyer t! == p && 9 === t.nodeType && t.documentElement? (p = t, f = t.documentElement, h =! s (t), r && r.attachEvent && r! == r.top && r.attachEvent ("onbeforeunload", fonction () {c ()}), n.attributes = ut (fonction (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ut (fonction (e) {return e.appendChild (t.createComment ("")),! e! getElementsByTagName ("*"). length}), n.getElementsByClassName = ut (fonction (e) {return e .innerHTML = "<div class = 'a'> </ div> <div class = 'a i'> </ div>", e.firstChild.className = "i", 2 === e.getElementsByClassName (" i "). length}), n.getById = ut (fonction (e) {return f.appendChild (e) .id = v,! t.getElementsByName ||! t.getElementsByName (v) .length}), n .getById? (i.find.ID = fonction (e, t) {if (typede t.getElementById! == j && h) {var n = t.getElementById (e); retourne n &&.parentNode? [n]: [] }}, i.filter.ID = function (e) {var t = e.replace (nt, rt); return function (e) {return e.getAttribute ("id") === t}}) :( supprimer i.find.ID, i.filter.ID = fonction (e) {var t = remplacement.e (nt, rt); fonction de retour (e) {var n = typeof e.getAttributeNode! == j && e.getAttributeNode ("id"); renvoie n && n.valeur === t}}), i.find.TAG = n.getElementsByTagName? fonction (e, t) {retourne le typede t.getElementsByTagName! =) = j? t.getElementsByTagName (e): undefined}: fonction (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, i.find.CLASS = n.getElementsByClassName && fonction (e, t) {return typeof t.getElementsByClassName ! == j && h? t.getElementsByClassName (e): undefined}, g = [], d = [], (n.qsa = Q.test (t.querySelectorAll)) && (ut (fonction (e) {e. innerHTML = "<select> <option selected = ''> </ option> </ select>", e.querySelectorAll ("[sélectionné]"). length || d.push ("\\ [" + M + "* (?: valeur | "+ R +") "), e.querySelectorAll (": vérifié ").longueur || d.push (": vérifié")}), ut (fonction (e) {var n = t.createElement ("entrée"); n.setAttribute ("type", "caché"), e.appendChild (n) .setAttribute ("t", ""), e.querySelectorAll ("[t ^ = '']]). length && d.push (" [* ^ $] = "+ M +" *?? " | \ "\") "), e.querySelectorAll (": activé "). length || d.push (": activé ",": désactivé "), e.querySelectorAll (" * ,: x "), d .push (",. *:")})), (n.matchesSelector = Q.test (m = f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ut (fonction (e ) {n.disconnectedMatch = m.call (e, "div"), m.call (e, "[s! = '']: x"), g.push ("! =", I)}), d = d.length && RegExp (d.join ("|")), g = g.length && RegExp (g.join ("|")),y = Q.test (f.contains) || f.compareDocumentPosition? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; return e == = r ||! (! r || 1! == r.nodeType ||! (n.contient? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) renvoie! 0; renvoie! 1}, S = f.compareDocumentPosition? fonction (e, r) {if (e === r ) retourne E =! 0,0; var i = r.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (r); retourne i? 1 & i ||! n.sortDetached && r.compareDocumentPosition (e) === i? e === t || y (b, e)? - 1: r === t || y (b, r)? 1: l? P.call (l, e) -P.call (l, r): 0: 4 & i? -1: 1: e.compareDocumentPosition? -1: 1}: fonction (e, n) {var r, i = 0, o = e.parentNode, s = n.parentNode, a = [e], u = [ n]; si (e === n) renvoie E =! 0,0; si (! o ||! s) renvoie e === t? -1: n === t? 1: o? -1 : s? 1: l? P.call (l, e) -P.call (l, n): 0;if (o === s) renvoie ct (e, n); r = e; tant que (r = r.parentNode) a.unshift (r); r = n; tant que (r = r.parentNode) u.unshift (r); while (a [i] === u [i]) i ++; retourne i? ct (a [i], u [i]): a [i] === b? -1: u [ i] === b? 1: 0}, t): p}, ot.matches = fonction (e, t) {retour ot (e, null, nul, t)}, ot.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == p && c (e), t = remplacer (Y, "= '$ 1']"),! (! n.matchesSelector ||! h || g && g.test (t) || d && d.test (t))) essayez {var r = m.call (e, t); if (r || n.disconnectedMatch || e.document && 11! == e.document. nodeType) return r} catch (i) {} return ot (t, p, null, [e]). length> 0}, ot.contains = function (e, t) {return (e.ownerDocument || e) ! == p && c (e), y (e, t)}, ot.attr = fonction (e, t) {(e.ownerDocument || e)! == p && c (e); var r = i.attrHandle [ t.toLowerCase ()], o = r && A.call (i.attrHandle, t.toLowerCase ())? r (e, t,! h): undefined; return o === undefined? n.attributes ||! h ? e.getAttribute (t) :( o = e.getAttributeNode (t)) && o.specified? o.value: null: o}, ot.error = function (e) {erreur ("Erreur de syntaxe, expression non reconnue:" + e )}, ot.uniqueSort = fonction (e) {var t, r = [], i = 0, o = 0; si (E =! n.detectDuplicates, l =! n.sortStable && e.slice (0), e .sort (S), E) {while (t = e [o ++]) t === e [o] && (i = r.push (o)); tandis que (i -) e.splice (r [ i], 1)} retourne e}, o = ot.getText = fonction (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i || 9 === i || 11 === i) {if ("chaîne" == typede e.textContent) retourne e.textContent; pour (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} sinon si (3 === i || 4 === i) retourne e.nodeValue} else pour (; t = e [r]; r ++) n + = o (t); retourne n }, i = ot.selectors = {cacheLength: 50, createPseudo: at, correspondance: J, attrHandle: {}, recherche: {}, relative: {">": {dir: "parentNode", première:! 0} , "": {dir: "parentNode"}, "+": {dir:"previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {retour e [1] = e [1] .replace (nt, rt) , e [3] = (e [4] || e [5] || ""). remplace (nt, rt), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, ENFANT: fonction (e) {retourne e [1] = e [1] .toLowerCase (), "nième" === e [ 1]. Slice (0,3)? (E [3] || ot.error (e [0]), e [4] = + (e [4]? E [5] + (e [6] | | 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3])): e [3] && ot.error (e [0]), e}, PSEUDO: fonction (e) {var t, n =! e [5] && e [2 ]; return J.CHILD.test (e [0])? null: (e [3] && e [4]! == undefined? e [2] = e [4]: ​​n && V.test (n) && (t = gt (n,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t) , e [2] = n.slice (0, t)), e.slice (0,3))}}, filtre: {TAG: function (e) {var t = e.replace (nt, rt) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {retourne e.nodeName && e.nodeName.toLowerCase () === t}} , CLASSE: fonction (e) {var t = C [e + ""]; retourne t || (t = RegExp ("(^ |" + M + ")" + e + "(" + M + "| $)") ) && C (e, fonction (e) {retourne t.test ("chaîne" == typedu nom e.classe && nom e.classe || type de e.getAttribute! == j && e.getAttribute ("classe") || "")) }, ATTR: fonction (e, t, n) {retourne fonction (r) {var i = ot.attr (r, e); retourne null == i? "! =" === t: t? (I + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t? n && 0 === i.indexOf ( n): "* =" === t? n && i.indexOf (n)> - 1: "$ =" === t? n && i.slice (-n.length) === n: "~ =" = == t? ("" + i + "") .indexOf (n)> - 1: "| ="=== t? i === n || i.slice (0, n.length + 1) === n + "-" :! 1) :! 0}}, ENFANT: fonction (e, t, n , r, i) {var o = "nth"! == e.slice (0,3), s = "dernier"! == e.slice (-4), a = "de type" === t; return 1 === r && 0 === i? function (e) {return !! e.parentNode}: function (t, n, u) {var l, c, p, f, h, d, g = o! == s? "nextSibling": "previousSibling", m = t.parentNode, y = a && t.nodeNom.toLowerCase (), x =! u &&! a; if (m) {si (o) {tant que (g ) {p = t; while (p = p [g]) if (a? p.nodeNom.toLowerCase () === y: 1 === p.nodeType) renvoie! 1; d = g = "uniquement" === e &&! d && "nextSibling"} return! 0} if (d = [s? m.firstChild: m.lastChild], s && x) {c = m [v] || (m [v] = {}) , l = c [e] || [], h = l [0] === w && l [1], f = l [0] === w && l [2], p = h && m.childNodes [h]; tandis que (p = ++ h && p && p [g] || (f = h = 0) || d.pop ()) if (1 === p.nodeType && ++ f && p === t) {c [e] = [ w, h, f];break}} else if (x && (l = (t [v] || (t [v] = {})) [e]) && l [0] === w) f = l [1]; sinon tant que ( p = ++ h && p && p [g] || (f = h = 0) || d.pop ()) if ((a? p.nodeName.toLowerCase () === y: 1 === p.nodeType) && ++ f && (x && ((p [v] || (p [v] = {})) [e] = [w, f]), p === t)) pause; retourne f- = i, f === r || 0 === f% r && f / r> = 0}}}, PSEUDO: fonction (e, t) {var n, r = i.pseudos [e] || i.setFilters [e .toLowerCase ()] || ot.error ("pseudo non pris en charge:" + e); return r [v]? r (t): r.length> 1? (n = [e, e, "", t] , i.setFilters.hasOwnProperty (e.toLowerCase ())? at (fonction (e, n) {var i, o = r (e, t), s = o.longueur; tandis que (s -) i = P .call (e, o [s]), e [i] =! (n [i] = o [s])}): fonction (e) {retour r (e, 0, n)}): r} }, pseudos: {pas: at (fonction (e) {var t = [], n = [], r = a (e.replace (z, "$ 1")); retour r [v]? at (fonction (e, t, n, i) {var o, s = r (e, nul, i, []), a = e.longueur; tandis que (a -) (o = s [a]) && (e [a] =! (t [a] = o))}): fonction (e, i,o) {return t [0] = e, r (t, null, o, n),! n.pop ()}}), a: at (fonction (e) {return fonction (t) {return ot ( e, t) .length> 0}}), contient: at (function (e) {return function (t) {return (t.textContent || t.innerText || o (t)). indexOf (e)> -1}}), lang: at (function (e) {return G.test (e || "") || ot.error ("lang non pris en charge:" + e), e = e.replace (nt, rt ) .toLowerCase (), fonction (t) {var n; faire si (n = h? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) retourne n = n .toLowerCase (), n === e || 0 === n.indexOf (e + "-"); while ((t = t.parentNode) && 1 === t.nodeType); return! 1}}) , cible: fonction (t) {var n = e.location && e.location.hash; retourne n && n.slice (1) === t.id}, racine: fonction (e) {retourne e === f}, focus : function (e) {return e === p.activeElement && (! p.hasFocus || p.hasFocus ()) && !! (type e || e.href || ~ e.tabIndex)}, activé: fonction (e) {retourne e.disabled ===! 1}, disabled: function (e) {return e.disabled ===! 0}, vérifié: function (e) {var t = e.nodeNome.toLowerCase (); retourne "entrée" == = t && !! e.checked || "option" === t && !! e.selected}, sélectionné: function (e) {return e.parentNode && e.parentNode.selectedIndex, e.selected ===! 0}, vide : fonction (e) {pour (e = e.firstChild; e; e = e.nextSibling) if (e.NodeName> "@" || 3 === e.nodeType || 4 === e.nodeType) return! 1; return! 0}, parent: fonction (e) {return! i.pseudos.empty (e)}, en-tête: fonction (e) {return et.test (e.nodeName)}, entrée: fonction ( e) {return Z.test (e.nodeName)}, bouton: fonction (e) {var t = nom.noeud.toLowerCase (); retourne "entrée" === t && "bouton" === e.type | | "bouton" === t}, texte: fonction (e) {var t; retourne "entrée" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || t.toLowerCase () === e.type)}, premier: ht (function () {return [0]}), dernier: ht (function (e, t) {return [t-1]}), eq: ht (fonction (e, t, n) {return [0> n? n + t: n]}), même: ht (fonction (e, t) {var n = 0; pour (; t> n; n + = 2) e.push (n); retour e}), impair: ht (fonction (e, t) {var n = 1; pour (; t> n; n + = 2) e.push (n); retour e}), lt: ht (fonction (e, t, n) {var r = 0> n? N + t: n; pour (; - r> = 0; ) e.push (r); retour e}), gt: ht (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; t> ++ r;) e .push (r); return e})}}, i.pseudos.nth = i.pseudos.eq; pour (t dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) i.pseudos [t] = pt (t); pour (t dans {submit:! 0, réinitialiser:! 0}) i.pseudos [t] = ft (t); fonction dt () {} dt.prototype = i.filters = i.pseudos, i.setFilters = new dt; fonction gt (e, t) {var n, r, o, s, a, u, l, c = k [e + " "]; if (c) retourne t? 0: c.slice (0); a = e, u = [], l = i.preFilter; tandis que (a) {(! n || (r = _. exec (a))) && (r && (a = a.slice (r [0].longueur) || a), u.push (o = [])), n =! 1, (r = X.exec (a)) && (n = r.shift (), o.push ({valeur: n, tapez: r [0] .remplace (z, "")}), a = a.slice (longueur n)); pour (s dans i.filter)! (r = J [s] .exec ( a)) || l [s] &&! (r = l [s] (r)) || (n = r.shift (), o.push ({valeur: n, type: s, correspond à: r} ), a = a.slice (n.length)); if (! n) break} retourne t? a.length: a? ot.error (e): k (e, u) .slice (0)} fonction mt (e) {var t = 0, n = longueur e, r = ""; pour (; n> t; t ++) r + = e [t] .value; retour r} fonction yt (e, t, n ) {var i = t.dir, o = n && "parentNode" === i, s = T ++; retourne t.first? fonction (t, n, r) {while (t = t [i]) if (1 === t.nodeType || o) retourne e (t, n, r)}: fonction (t, n, a) {var u, l, c, p = w + "" + s; si (a) { while (t = t [i]) if ((1 === t.nodeType || o) && e (t, n, a)) renvoie! 0} sinon (t = t [i]) if (1 = == t.nodeType || o) if (c = t [v] || (t [v] = {}), (l = c [i]) && l [0] === p) {if (( u = l [1]) ===! 0 || u === r) renvoie u ===! 0} sinon si (l = c [i] = [p], l [1] = e (t , n, a) || r,l [1] ===! 0) return! 0}} function vt (e) {return e.length> 1? function (t, n, r) {var i = e.length; tant que (i--) if (! e [i] (t, n, r)) renvoie! 1; renvoie! 0}: e [0]} fonction xt (e, t, n, r, i) {var o, s = [] , a = 0, u = longueur e, l = null! = t; pour (; u> a; a ++) (o = e [a]) && (! n || n (o, r, i)) && (s.push (o), l && t.push (a)); retourne s} fonction bt (e, t, n, r, i, o) {retourne r &&! r [v] && (r = bt (r )), i &&! i [v] && (i = bt (i, o)), en (fonction (o, s, a, u)) {var l, c, p, f = [], h = [] , d = s.longueur, g = o || Ct (t || "*", a.nodeType? [a]: a, []), m =! e ||! o && t? g: xt (g, f, e, a, u), y = n? i || (o? e: d || r)? []: s: m; si (n && n (m, y, a, u), r) { l = xt (y, h), r (l, [], a, u), c = l.longueur; tandis que (c -) (p = l [c]) && (y [h [c]] =! (m [h [c]] = p))} si (o) {si (i || e) {si (i) {l = [], c = y.longueur; tant que (c--) (p = y [c]) &&.push (m [c] = p); i (nul, y = [], l, u)} c = y.longueur; tandis que (c -) (p = y [c]) && (l = i? P.call (o, p): f [c])> - 1 && (o [l] =!(s [l] = p))}} sinon y = xt (y === s? y.splice (d, y.length): y), i? i (null, s, y, u): O .apply (s, y)})} fonction wt (e) {var t, n, r, o = e.longueur, s = i.relative [e [0] .type], a = s || i. relatif [""], l = s? 1: 0, c = yt (fonction (e) {retour e === t}, a,! 0), p = yt (fonction (e) {retour P.call (t, e)> - 1}, a,! 0), f = [fonction (e, n, r) {retour! s && (r || n! == u) || ((t = n). nodeType? c (e, n, r): p (e, n, r))}]; pour (; o> l; l ++) if (n = i.relatif [e [l]. type]) f = [yt (vt (f), n)]; sinon {si (n = i.filtre [e [l] .type] .apply (null, e [l] .matches), n [v]) {pour ( r = ++ l; o> r; r ++) si (i.relative [e [r]. type]) pause; retourne bt (l> 1 && vt (f), l> 1 && mt (e.slice (0, l- 1) .concat ({valeur: "" === e [l-2] .type? "*": ""})). Remplacer (z, "$ 1"), n, r> l && wt (e.slice (l, r)), o> r && wt (e = e.slice (r)), o> r && mt (e)) f.push (n)} retour vt (f)} fonction Tt (e, t) { var n = 0, o = t.longueur> 0, s = e.longueur> 0,a = fonction (a, l, c, f, h) {var d, g, m, y = [], v = 0, x = "0", b = a && [], T = null! = h, C = u, k = a || s && i.find.TAG ("*", h && l.parentNode || l), N = w + = null == C? 1: Math.random () || .1; pour ( T && (u = l! ​​== p && l, r = n); null! = (D = k [x]); x ++) {si (s && d) {g = 0; tant que (m = e [g ++]) si ( m (d, l, c)) {f.push (d); pause} T && (w = N, r = ++ n)} o && ((d =! m && d) && v -, a && b.push (d) )} if (v + = x, o && x! == v) {g = 0; tandis que (m = t [g ++]) m (b, y, l, c); si (a) {if (v> 0) tandis que (x -) b [x] || y [x] || (y [x] = q.call (f)); y = xt (y)} O.apply (f, y), T &&! a && y.length> 0 && v + t.length> 1 && ot.uniqueSort (f)} retourne T && (w = N, u = C), b}; retourne o? en (a): a} a = ot.compile = fonction ( e, t) {var n, r = [], i = [], o = N [e + ""]; si (! o) {t || (t = gt (e)), n = t.longueur ; tandis que (n -) o = wt (t [n]), o [v]? r.push (o): i.push (o); o = N (e, Tt (i, r))} retour o}; fonction Ct (e, t,n) {var r = 0, i = t.longueur; pour (; i> r; r ++) ot (e, t [r], n); retour n} fonction kt (e, t, r, o) { var s, u, l, c, p, f = gt (e); si (! o && 1 === f.length) {si (u = f [0] = f [0] .slice (0), u .length> 2 && "ID" === (l = u [0]). type && n.getById && 9 === t.nodeType && h && i.relative [u [1] .type]) {if (t = (i.find.ID (l.matches [0] .replace (nt, rt), t) || []) [0],! t) retourne r; e = e.slice (u.shift (). valeur.longueur)} s = J.needsContext.test (e)? 0: u.length; tandis que (s -) {if (l = u [s], i.relative [c = l.type]) break; if ((p = i.find [c]) && (o = p (l.matches [0] .replace (nt, rt), U.test (u [0] .type) && t.parentNode || t))) {if ( u.plice (s, 1), e = longueur.longueur && mt (u),! e) retourne O.apply (r, o), r; pause}}} retourne a (e, f) (o, t,! h, r, U.test (e)), r} n.sortStable = v.split (""). sort (S) .join ("") === v, n.detectDuplicates = E, c () , n.sortDetached = ut (fonction (e) {return 1 & e.compareDocumentPosition (p.createElement ("div"))}), ut (fonction (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute (" href ")}) || lt (" type | href | height | width ", fonction (e, t, n) {return n? undefined: e.getAttribute (t," type "=== t.toLowerCase () ? 1: 2)}), n.attributes && ut (fonction (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("valeur", ""), "" "=== e. firstChild.getAttribute ("valeur")}) || lt ("valeur", fonction (e, t, n) {retour n || "entrée"! == e.nodeName.toLowerCase ()? undefined: e.defaultValue }), ut (fonction (e) {return null == e.getAttribute ("désactivé")}) || lt (R, fonction (e, t, n) {var r; retourne n? non défini: (r = e.getAttributeNode (t)) && r.specified? r.value: e [t] ===! 0? t.to.LowerCase (): null}), x.find = ot, x.expr = ot.sélecteurs, x.expr [":"] = x.expr.pseudos, x.unique = ot.uniqueSort, x.text = ot.getText, x.isXMLDoc = ot.isXML, x.contains = ot.contains} ( e); var D = {}; fonction A (e) {var t = D [e] = {}; retour x.each (e.match (w) || [], fonction (e, n) {t [n] =! 0}), t} x.Callbacks = fonction (e) {e = "chaîne" == typedee? D [e] || A (e): x.extend ({}, e) ; var t, n, r, i, o, s, a = [], u =! e.once && [], l = fonction (p) {pour (t = e.memory && p, n =! 0, s = i || 0, i = 0, o = longueur, r =! 0; a && o> s ++) if (a [s] .apply (p [0], p [1]) ===! 1 && e .stopOnFalse) {t =! 1; break} r =! 1, a && (u? u.longueur && l (u.shift ()): t? a = []: c.disable ())}, c = {add : fonction () {si (a) {var n = a.longueur; (fonction s (t) {x.each (t, fonction (t, n) {var r = x.type (n); "fonction" === r? e.unique && c.has (n) || a.push (n): n && n.length && "chaîne"! == r && s (n)})}) (arguments), r? o = a.length : t && (i = n,l (t))} retourne cette}, remove: function () {retourne a && x.each (arguments, fonction (e, t) {var n; tant que ((n = x.inArray (t, a, n))>> -1) a.splice (n, 1), r && (o> = n && o -, s> = n && s -)}), this}, a: function (e) {return e? X.inArray (e, a)> - 1:! (! a ||! a.length)}, vide: fonction () {retourne a = [], o = 0, ceci}, désactive: fonction () {retourne a = u = t = non défini, ceci}, désactivé: fonction () {retour! a}, verrouiller: fonction () {retour u = non défini, t || c.disable (), this}, verrouillé: fonction () {retour! u} , fireWith: function (e, t) {return! a || n &&! u || (t = t || [], t = [e, t.slice? t.slice (): t], r? u .push (t): l (t)), this}, fire: function () {return c.fireWith (this, arguments), this}, déclenché: function () {return !! n}}; return c} , x.extend ({Différé: fonction (e) {var t = [["résoudre", "terminé", x.Callbacks ("une fois en mémoire"), "résolu"], ["rejeter", "échouer", x.Callbacks ("une fois mémoire ")," rejeté "], [" notifier "," progression ", x.Callbacks (" mémoire ")]], n =" en attente ", r = {état: fonction () {retour n}, toujours : function () {return i.done (arguments) .fail (arguments), this}, alors: function () {var e = arguments; renvoie x.Deferred (fonction (n) {x.each (t, fonction ( t, o) {var s = o [0], a = x.isFunction (e [t]) && e [t]; i [o [1]] (function () {var e = a && a.apply (this, arguments); e && x.isFunction (e.promise)? e.promise (). done (n.resolve) .fail (n.reject) .progress (n.notify): n [s + "Avec"] (this == = r? n.promise (): this, a? [e]: arguments)})}, e = null}). promise ()}, promesse: fonction (e) {retourne null! = e? x. étendre (e, r): r}}, i = {}; retourne r.pipe = r.then, x.each (t, fonction (e, o) {var s = o [2], a = o [ 3]; r [o [1]] = s.add, a && s.add (fonction () {n = a}, t [1 ^ e] [2] .disable, t [2] [2] .lock) , i [o [0]] = fonction () {retourne i [o [0] + "avec"] (this === i? r: this, arguments), this}, i [o [0] + "Avec"] = s.fireWith}), r.promise (i), e && e.call (i, i ), i}, quand: fonction (e) {var t = 0, n = d.call (arguments), r = longueur n, i = 1! == r || e && x.isFunction (promesse)? r: 0, o = 1 === i? e: x.Deferred (), s = fonction (e, t, n) {retour fonction (r) {t [e] = ceci, n [e] = arguments .length> 1? d.call (arguments): r, n === a? o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, a, u, l ; si (r> 1) pour (a = tableau (r), u = tableau (r), l = tableau (r); r> t; t ++) n [t] && x.isFunction (n [t] .promise )? n [t] .promise (). done (s (t, l, n)). échec (o.réjecter) .progress (s (t, u, a)): - i; retour i || o.resolveWith (l, n), o.promise ()}}), x.support = fonction (t) {var n = o.createElement ("input"), r = o.createDocumentFragment (), i = o .createElement ("div"), s = o.createElement ("select"), a = s.appendChild (o.createElement ("option")); retourne n.type? (n.type = "case à cocher", t.checkOn = ""! == n.valeur, t.optSelected = a.selected, t.reliableMarginRight =! 0, t.boxSizingReliable =! 0, t.pixelPosition =! 1, n.checked =! 0, t.noCloneChecked = n.cloneNode (! 0). vérifié, s.disabled =! 0, t.optDisabled =! a.disabled, n = o.createElement ("entrée"), n.value = "t", n .type = "radio", t.radioValue = "t" === n.valeur, n.setAttribute ("vérifié", "t"), n.setAttribute ("nom", "t"), r.appendChild (n), t.checkClone = r.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, t.focusinBubbles = "onfocusin" dans e, i.style.backgroundClip = "content-box", i. cloneNode (! 0) .style.backgroundClip = "", t.clearCloneStyle = "content-box" === i.style.backgroundClip, x (fonction () {var n, r, s = "padding: 0; marge : 0; bordure: 0; affichage: bloc; -webkit-box-sizing: contenu-box; -moz-box-sizing: contenu-box;taille de boîte: contenu-boîte ", a = o.getElementsByTagName (" body ") [0]; a && (n = o.createElement (" div "), n.style.cssText =" border: 0; width: 0 ; height: 0; position: absolute; top: 0; left: -9999px; margin-top: 1px ", a.appendChild (n) .appendChild (i), i.innerHTML =" ", i.style.cssText = "-webkit-box-sizing: border-box; -moz-box-sizing: border-box; dimensionnement de la boîte: border-box; remplissage: 1px; border: 1px; affichage: bloc; largeur: 4px; margin-top : 1%; position: absolue; haut: 1% ", x.swap (a, null! = A.style.zoom? {Zoom: 1}: {}, function () {t.boxSizing = 4 === i.offsetWidth}), e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (i, null) || {}). début, t.boxSizingReliable = "4px" === (e .getComputedStyle (i, null) || {width: "4px"}). width, r = i.appendChild (o.createElement ("div")), r.style.cssText = i.style.cssText = s, style.marginRight = r.style.width = "0", i.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) || {}). marginRight), a. removeChild (n))}), t): t} ({}); var L, q, H = / (?: \ {[\ s \ s] * \} | \ [[\ s \ s] * \]) $ /, O = / ([AZ]) / g; fonction F () {Object.defineProperty (this.cache = {}, 0, {get: function () {return {}}}), cela .expando = x.expando + Math.random ()} F.uid = 1, F.accepts = function (e) {retourne e.nodeType? 1 === e.nodeType || 9 === e.nodeType: ! 0}, F.prototype = {clé: fonction (e) {if (! F.accepts (e)) renvoie 0; var t = {}, n = e [ceci.expando]; if (! N) { n = F.uid ++; essayez {t [this.expando] = {valeur: n}, Object.defineProperties (e, t)} catch (r) {t [this.expando] = n, x.extend (e, t)}} retourne this.cache [n] || (this.cache [n] = {}), n}, ensemble: fonction (e, t, n) {var r, i = ceci.key (e) , o = this.cache [i]; if ("chaîne" == type de t) o [t] = n; sinon if (x.isEmptyObject (o)) x.extend (this.cache [i], t) ; else pour (r dans t) o [r] = t [r];retour o}, get: fonction (e, t) {var n = this.cache [this.key (e)]; retour t === non défini? n: n [t]}, accès: fonction (e, t , n) {var r; retourne t === undefined || t && "chaîne" == typede t && n === undefined? (r = this.get (e, t), r! == undefined? r: this. get (e, x.camelCase (t))) :( this.set (e, t, n), n! == non défini? n: t)}, supprime: fonction (e, t) {var n, r , i, o = this.key (e), s = this.cache [o]; if (t === non défini) this.cache [o] = {}; sinon {x.isArray (t)? r = t.concat (t.map (x.camelCase)) :( i = x.camelCase (t), t dans s? r = [t, i] :( r = i, r = r dans s? [r] : r.match (w) || [])), n = r.length; tandis que (n -) supprime s [r [n]]}}, hasData: function (e) {return! x.isEmptyObject ( this.cache [e [this.expando]] || {})}, ignore: fonction (e) {e [this.expando] && supprimez this.cache [e [this.expando]]}}, L = nouveau F , q = new F, x.extend ({acceptData: F.accepts, hasData: function (e) {return L.hasData (e) || q.hasData (e)}, data: function (e, t, n ) {retourne L.access (e, t, n)},removeData: fonction (e, t) {L.remove (e, t)}, _données: fonction (e, t, n) {retourne q.access (e, t, n)}, _ removeData: fonction (e, t ) {q.remove (e, t)}}), x.fn.extend ({données: fonction (e, t) {var n, r, i = ce [0], o = 0, s = null; if (e === non défini) {if (this.length && (s = L.get (i), 1 === i.nodeType &&! q.get (i, "hasDataAttrs"))) {pour (n = i .attributes; n.length> o; o ++) r = n [o] .nom, 0 === r.indexOf ("data -") && (r = x.camelCase (r.slice (5)), P (i, r, s [r])); q.set (i, "hasDataAttrs",! 0)} retourne s} retourne "objet" == type de e? ceci.each (fonction () {L.set ( this, e)}): x.access (this, function (t) {var n, r = x.camelCase (e); if (i && t === non défini) {if (n = L.get (i, e ), n! == non défini) retourne n; si (n = L.get (i, r), n! == non défini) retourne n; si (n = P (i, r, non défini), n! == undefined) retourne n} sinon this.each (function () {var n = L.get (this, r); L.set (this, r, t), - 1! == e.indexOf ("-") && n!== undefined && L.set (this, e, t)}), null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {retour this.each (function () {L .remove (this, e)})}}); fonction P (e, t, n) {var r; if (n === non défini && 1 === e.nodeType) if (r = "data -" + t .replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne" == type de n) {try {n = "true" === n?! 0: "false "=== n?! 1:" null "=== n? null: + n +" "=== n? + n: H.test (n)? JSON.parse (n): n} attrape (i ) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (T = (t | | "fx") + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e, t, x.makeArray (n) ): r.push (n)), r || []): indéfini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = longueur.i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)set (this, e, t)})}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {renvoie this.each (function () {L.remove (this , e)})}}); fonction P (e, t, n) {var r; si (n === non défini && 1 === e.nodeType) if (r = "data -" + t.replace (O , "- $ 1"). ToLowerCase (), n = e.getAttribute (r), "string" == typeof n) {try {n = "true" === n?! 0: "false" === n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} capture (i) {} L .set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx" ) + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e, t, x.makeArray (n)): r. push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x. file d'attente (e, t), r = n. longueur, i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)set (this, e, t)})}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {renvoie this.each (function () {L.remove (this , e)})}}); fonction P (e, t, n) {var r; si (n === non défini && 1 === e.nodeType) if (r = "data -" + t.replace (O , "- $ 1"). ToLowerCase (), n = e.getAttribute (r), "string" == typeof n) {try {n = "true" === n?! 0: "false" === n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} capture (i) {} L .set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx" ) + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e, t, x.makeArray (n)): r. push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x. file d'attente (e, t), r = n. longueur, i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)0)}, removeData: function (e) {retourne this.each (function () {L.remove (this, e)})}}); fonction P (e, t, n) {var r; if (n === undefined && 1 === e.nodeType) if (r = "data -" + t.replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne" == typeof n) {try {n = "true" === n?! 0: "false" === n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r || x. isArray (n)? r = q.access (e, t, x.makeArray (n)): r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) { t = t || "fx"; var n = x.queue (e, t), r = longueur n, i = n.shift (), o = x._queueHooks (e, t), s = fonction ( ) {x.dequeue (e, t)0)}, removeData: function (e) {retourne this.each (function () {L.remove (this, e)})}}); fonction P (e, t, n) {var r; if (n === undefined && 1 === e.nodeType) if (r = "data -" + t.replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne" == typeof n) {try {n = "true" === n?! 0: "false" === n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r || x. isArray (n)? r = q.access (e, t, x.makeArray (n)): r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) { t = t || "fx"; var n = x.queue (e, t), r = longueur n, i = n.shift (), o = x._queueHooks (e, t), s = fonction ( ) {x.dequeue (e, t)if (n === non défini && 1 === e.nodeType) if (r = "données -" + t.replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne "== typeof n) {try {n =" true "=== n?! 0:" false "=== n?! 1:" null "=== n? null: + n +" "=== n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ( {file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r | | x.isArray (n)? r = q.access (e, t, x.makeArray (n)): r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x. file (e, t), r = longueur.i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)if (n === non défini && 1 === e.nodeType) if (r = "données -" + t.replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne "== typeof n) {try {n =" true "=== n?! 0:" false "=== n?! 1:" null "=== n? null: + n +" "=== n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ( {file d'attente: fonction (e, t, n) {var r; retourne e? (t = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r | | x.isArray (n)? r = q.access (e, t, x.makeArray (n)): r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x. file (e, t), r = longueur.i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)=== n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (T = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e, t, x.makeArray (n)) : r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = n.longueur, i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)=== n?! 1: "null" === n? null: + n + "" === n? + n: H.test (n)? JSON.parse (n): n} catch (i) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r; retourne e? (T = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e, t, x.makeArray (n)) : r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = n.longueur, i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)
}; "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), supprimez o.stop, i.call (e , s, o)),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; retourne q.get (e, n) || q.access (e , n, {vide: x.Callbacks ("une fois en mémoire"). add (function () {q.remove (e, [t + "file d'attente", n])})}}}), x.fn.extend ({file: function (e, t) {var n = 2; retourne "chaîne"! = typede e && (t = e, e = "fx", n -), n> arguments.length? x.queue ( ceci [0], e): t === non défini? ceci: ceci.chaque (fonction () {var n = x.queue (ceci, e, t); x._queueHooks (ceci, e), "fx" === e && "inprogress"! == n [0] && x.dequeue (this, e)})}, file d'attente: function (e) {retourne this.each (fonction () {x.dequeue (this, e) })}, délai: fonction (e, t) {retour e = x.fx? x.fx.speeds [e] || e: e, t = t || "fx",this.queue (t, fonction (t, n) {var r = setTimeout (t, e); n.stop = fonction () {clearTimeout (r)}})}, clearQueue: fonction (e) {renvoie ceci. file d'attente (e || "fx", [])}, promesse: fonction (e, t) {var n, r = 1, i = x. différé (), o = ceci, s = ceci.longueur, a = function () {- r || i.resolveWith (o, [o])}; "chaîne"! = typede e && (t = e, e = indéfini), e = e || "fx"; tandis que (s -) n = q.get (o [s], e + "queueHooks"), n && n.empty && (r ++, n.empty.add (a)); renvoyer a (), i.promise (t)}}) ; var R, M, W = / [\ t \ r \ n \ f] / g, $ = / \ r / g, B = / ^ (?: input | select | textarea | button) $ / i; x .fn.extend ({attr: function (e, t) {return x.access (this, x.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {retour this.each ( function () {x.removeAttr (this, e)})}, prop: function (e, t) {renvoie x.access (this, x.prop, e, t, arguments.length> 1)}, removeProp: function (e) {retour this.each (function () {delete this [x.propFix [e] || e]})},addClass: function (e) {var t, n, r, i, o, s = 0, a = this.length, u = "chaîne" == typede e && e; si (x.isFunction (e)) le renvoie. each (fonction (t) {x (this) .addClass (e.call (this, t, this.className))}); if (u) pour (t = (e || ""). match (w) || []; a> s; s ++) if (n = ce [s], r = 1 === n.nodeType && (n.className? ("" + n.className + "") .replace (W, " "):" ")) {o = 0; tandis que (i = t [o ++]) 0> r.indexOf (" "+ i +" ") && (r + = i +" "); n.className = x.trim (r)} retourne cette}, removeClass: fonction (e) {var t, n, r, i, o, s = 0, a = this.length, u = 0 === arguments.length || "chaîne" == typeof e && e; if (x.isFunction (e)) renvoie this.each (fonction (t) {x (this) .removeClass (e.call (this, t, this.className))}); if (u ) pour (t = (e || ""). match (w) || []; a> s; s ++) if (n = ce [s], r = 1 === n.nodeType && (n.className ? ("" + n.className + "") .replace (W, ""): "")) {o = 0; tandis que (i = t [o ++]) tandis que (r.indexOf ("" + i + "")> = 0) r = r.replace ("" + i + "", ""); n.className = e? x.trim (r): ""} renvoie ceci}, toggleClass: fonction (e, t) {var n = typeof e; return "boolean" == typeof t && "string" === n? t? this.addClass (e): this.removeClass (e): x.isFunction (e)? this.each (fonction (n) {x ( this) .toggleClass (e.call (this, n, this.className, t), t)}): this.each (fonction () {if ("chaîne" === n) {variable, i = 0 , o = x (ceci), s = e.match (w) || []; tandis que (t = s [i ++]) o.hasClass (t)? o.removeClass (t): o.addClass (t) } else (n === r || "boolean" === n) && (this.className && q.set (this, "__ className __", this.className), this.className = this.className || e === ! 1? "": Q.get (this, "__ className __") || "")})}, hasClass: function (e) {var t = "" + e + "", n = 0, r = this.length; pour (; r> n; n ++) si (1 === ceci [n ] .nodeType && ("" + this [n] .className + "") .replace (W, "") .indexOf (t)> = 0) renvoie! 0; renvoie! 1}, val: fonction (e) {var t, n, r, i = this [0]; {if (arguments.length) renvoie r = x.isFunction (e), this.each (fonction (n) {var i; 1 === this.nodeType && ( i = r? e.call (this, n, x (this) .val ()): e, null == i? i = "": "nombre" == type de i? i + = "": x.isArray (i) && (i = x.map (i, fonction (e) {retour null == e? "": e + ""})), t = x.valHooks [this.type] || x.valHooks [ this.nodeName.toLowerCase ()], t && "set" dans t && t.set (this, i, "value")! == undefined || (this.value = i))}); si (i) retourne t = x.valHooks [i.type] || x.valHooks [i.nodeName.toLowerCase ()], t && "get" dans t && (n = t.get (i,"valeur"))! == non défini? n: (n = i.valeur, "chaîne" == typede n? n.replace ($, ""): null == n? "": n)}}} ), x.extend ({valHooks: {option: {get: function (e) {var t = e.attributes.value; retourne! t || t.| spécifiée? e.value: e.text}}, sélectionnez: {get: function (e) {vart, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0> i, s = o? null: [], a = o? i + 1: r.longueur, u = 0> i? a: o? i: 0; pour (; a> u; u ++) si (n = r [u],! (! n.selected && u! == i || (x.support.optDisabled? n.disabled: null! == n.getAttribute ("disabled")) || n.parentNode.disabled && x.nodeName (n.parentNode, "optgroup" ))) {if (t = x (n) .val (), o) renvoie t; s.push (t)} renvoie s}, définit: fonction (e, t) {var n, r, i = e .options, o = x.makeArray (t), s = i.length; tandis que (s -) r = i [s], (r.sélectionné = x.inArray (x (r) .val (), o )> = 0) && (n =! 0); retourne n || (e.selectedIndex = -1), o}}}, attr: fonction (e, t, n) {var i, o, s = e .nodeType; if (e && 3! == s && 8! == s && 2! == s) renvoie le typede e.getAttribute === r? x.prop (e, t, n) :( 1 === s && x.isXMLDoc (e) || (t = t.toLowerCase (), i = x.attrHooks [t] || (x.expr.match.bool.test (t)? M: R)), n === undefined? i && "get "in i && null! == (o = i.get (e, t))? o: (o = x.find.attr (e, t), null == o? indéfini: o): null! == n ? i && "set" dans i && (o = i.set (e, n, t))! == non défini? o: (e.setAttribute (t, n + ""), n) :( x.removeAttr (e, t), undefined))}, removeAttr: fonction (e, t) {var n, r, i = 0, o = t && t.match (w); if (o && 1 === e.nodeType) tandis que (n = o [i ++]) r = x.propFix [n] || n, x.expr.match.bool.test (n) && (e [r] =! 1), e.removeAttribute (n)}, attrHooks: { type: {set: function (e, t) {if (! x.support.radioValue && "radio" === t && x.nodeName (e, "input")) {var n = e.value; renvoie e.setAttribute ( "type", t), n && (e.value = n), t}}}}, propFix: {"pour": "htmlFor", "class": "className"}, prop: fonction (e, t, n) {var r, i , o, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) renvoie o = 1! == s ||! x.isXMLDoc (e), o && (t = x.propFix [t] || t, i = x.propHooks [t]), n! == undefined? i && "set" dans i && (r = i.set (e, n, t))! == undefined? r: e [t] = n: i && "get" dans i && null! == (r = i.get (e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) { renvoyer e.hasAttribute ("tabindex") || B.test (e.nodeName) || e.href? e.tabIndex: -1}}}}), M = {set: fonction (e, t, n) {return t ===! 1? x.removeAttr (e, n): e.setAttribute (n, n), n}}, x.each (x.expr.match.bool.source.match (/ / \ w + / g), fonction (e, t) {var n = x.expr.attrHandle [t] || x.find.attr; x.expr.attrHandle [t] = fonction (e, t, r) {var i = x.expr.attrHandle [t], o = r? indéfini: (x.expr.attrHandle [t] = indéfini)! = n (e, t, r)? t.toLowerCase (): null; renvoie x.expr.attrHandle [t] = i, o}}), x.support.optSélectionné || (x.propHooks.selected = {get: function (e) {var t = e.parentNode; renvoyer t && t.parentNode && t.parentNode.selectedIndex, null}}), x.each (["tabIndex", "readOnly", " maxLength "," cellSpacing "," cellPadding "," rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {x.propFix [this.toLowerCase ()] = this}) , x.each (["radio", "case à cocher"], function () {x.valHooks [this] = {set: function (e, t) {renvoie x.isArray (t)? e.checked = x. inArray (x (e) .val (), t)> = 0: non défini}}, x.support.checkOn || (x.valHooks [this] .get = function (e) {retour null === e. getAttribute ("valeur")? "sur": e.valeur})}); var I = / ^ clé /, z = / ^ (?:mouse | contextmenu) | click /, _ = / ^ (?: focusinfocus | focusoutblur) $ /, X = / ^ ([^.] *) (?: \. (. +) |) $ /; fonction U ( ) {return! 0} function Y () {return! 1} function V () {try {return o.activeElement} catch (e) {}} x.event = {global: {}, ajouter: function (e, t, n, i, o) {var s, a, u, l, c, p, f, h, d, g, m, y = q.get (e); if (y) {n.handler && ( s = n, n = gestionnaire, o = sélecteur), n.guid || (n.guid = x.guid ++), (l = y. événements) || (l = y. événements = {} ), (a = y.handle) || (a = y.handle = fonction (e) {type de retour x === r || e && x.event.triggered === e.type? undefined: x.event. dispatch.apply (a.elem, arguments)}, a.elem = e), t = (t || ""). match (w) || [""], c = t.longueur; tandis que (c- -) u = X.exec (t [c]) || [], d = m = u [1], g = (u [2] || ""). split ("."). sort () , d && (f = x.event.special [d] || {}, d = (o? f.delegateType: f.bindType) || d, f = x.event.special [d] || {}, p = x.extend ({type: d, origType: m, données: i, gestionnaire: n, guid: n.guid, sélecteur: o, needsContext:o && x.expr.match.needsContext.test (o), espace de noms: g.join (".")}, s), (h = l [d]) || (h = l [d] = [], h .delegateCount = 0, f.setup && f.setup.call (e, i, g, a)! ==! 1 || e.addEventListener && e.addEventListener (d, a,! 1)), f.add && (f.add .call (e, p), p.handler.guid || (p.handler.guid = n.guid)), o? h.splice (h.delegateCount ++, 0, p): h.push (p), x.event.global [d] =! 0); e = null}}, supprimer: fonction (e, t, n, r, i) {var o, s, a, u, l, c, p, f , h, d, g, m = q.hasData (e) && q.get (e); if (m && (u = m.events)) {t = (t || ""). match (w) || [""], l = t.longueur; tant que (l -) si (a = X.exec (t [l]) || [], h = g = a [1], d = (a [2 ] || ""). split ("."). sort (), h) {p = x.événement.spécial [h] || {}, h = (r? p.delegateType: p.bindType) | | h, f = u [h] || [], a = a [2] && RegExp ("(^ | \\.)" + d.join ("\\. (?:. * \\. |) ") +" (\\. | $) "), s = o = f.length; tandis que (o -) c = f [o],! i && g! == c.origType || n && n.guid! == c.guid || a &&! a.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) | | (f.splice (o, 1), c.selector && f.delegateCount -, p.remove && p.remove.call (e, c)); s &&! f.length && (p.teardown && p.teardown.call (e, d , m.handle)! ==! 1 || x.removeEvent (e, h, m.handle), supprimez u [h])} sinon pour (h en u) x.event.remove (e, h + t [l], n, r,! 0); x.isEmptyObject (u) && (supprimer m.handle, q.remove (e, "events"))}}, déclencheur: function (t, n, r, i ) {var s, a, u, l, c, p, f, h = [r || o], d = y.call (t, "type")? t.type: t, g = y.call (t, "namespace")? t.namespace.split ("."): []; if (a = u = r = r || o, 3! == r.nodeType && 8! == r.nodeType &&! _ .test (d + x.event.triggered) && (d.indexOf (".")> = 0 && (g = d.split ("."), d = g.shift (), g.sort ()) , c = 0> d.indexOf (": ") &&" on "+ d, t = t [x.expando]? t: new x.Event (d," objet "== typede t && t), t.isTrigger = i? 2: 3, t.namespace = g.join ("."), t.namespace_re = t.namespace? RegExp ("(^ | \\.)" + g.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, t.result = indéfini, t.target || (t.target = r), n = null == n? [t]: x.makeArray (n, [t]), f = x.événement.spécial [d] || {}, i ||! f.trigger || f.trigger.apply (r, n)! ==! 1)) {if (! i &&! f.noBubble &&! x.isWindow (r)) {pour (l = f.delegateType || d, _. test (l + d) || (a = a.parentNode); a; a = a.parentNode ) h.push (a), u = a; u === (r.ownerDocument || o) && h.push (u.defaultView || u.parentWindow || e)} s = 0; while ((a = h [s ++]) &&! t.isPropagationStopped ()) t.type = s> 1? l: f.bindType || d, p = (q.get (a, "événements") || {}) [t .type] && q.get (a, "handle"), p && p.apply (a, n), p = c && a [c], p && x.acceptData (a) && p.apply && p.apply (a, n) ===! 1 && t.preventDefault (); renvoyer t.type = d, i || t.isDefaultPrevented () || f._default && f._default.apply (h .pop (), n)! ==! 1 ||! x.acceptData (r) || c && x.isFunction (r [d]) &&! x.isWindow (r) && (u = r [c], u && (r [c] = null), x.event.triggered = d, r [d] (), x.event.triggered = undefined, u && (r [c] = u)), t.result}}, dispatch : fonction (e) {e = x.event.fix (e); var t, n, r, i, o, s = [], a = d.call (arguments), u = (q.get (this , "événements") || {}) [type.e] || [], l = x.événement.spécial [type.] || {}; if (a [0] = e, e.delegateTarget = this,! l.preDispatch || l.preDispatch.call (this, e)! ==! 1) {s = x.event.handlers.call (this, e, u), t = 0; tant que ((i = s [t ++]) &&! e.isPropagationStopped ()) {e.currentTarget = i.elem, n = 0; tandis que ((o = i.handlers [n ++]) &&! e.isImmediatePropagationStopped ()) (! e .namespace_re || e.namespace_re.test (o.espace de noms)) && (e.handleObj = o, e.data = o.data, r = ((x.event.special [o.origType] || {}). handle || o.handler) .apply (i .elem, a), r! == non défini && (e.result = r) ===! 1 && (e.preventDefault (), e.stopPropagation ()))} return l.postDispatch && l.postDispatch.call (this, e ), e.result}}, gestionnaires: fonction (e, t) {var, n, r, i, s = [], a = t.delegateCount, u = e.target; if (a && u.nodeType && (! e.button || "cliquez"! == e.type)) pour (; u! == this; u = u.parentNode || this) if (u.disabled! ==! 0 || "click"! == e.type) {pour (r = [], n = 0; a> n; n ++) o = t [n], i = o.secteur + "", r [i] === non défini && (r [ i] = o.needsContext? x (i, this) .index (u)> = 0: x.find (i, this, null, [u]). length), r [i] && r.push (o) ; r.length && s.push ({elem: u, gestionnaires: r})} retournent t.length> a && s.push ({elem: this, gestionnaires: t.slice (a)}), s}, props: "altKey bulles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp vue qui ".split (" "), fixHooks: {}, keyHooks: {props:" char charCode key keyCode ".split (" "), filtre: fonction (e, t) {return null == e.which && (e.which = null! = t.charCode? t.charCode: t.keyCode), e}}, mouseHooks: {props: "boutons boutons clientX clientY offsetX pageY pageY écranX screenY toElement ".split (" "), filtre: fonction (e, t) {variable, r, i, s = t.button; retourne null == e.pageX && null! = t.clientX && (n = e.target .ownerDocument || o, r = n.documentElement, i = n.organ, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || s === undefined || (e.which = 1 & s? 1: 2 & s? 3: 4 & s? 2: 0), e}}, correction: fonction (e) { if (e [x.expando]) renvoie e; var t, n, r, i = e.type, s = e, a = this.fixHooks [i]; a || (this.fixHooks [i] = a = z.test (i)? this.mouseHooks: I.test (i)? this.keyHooks: {}), r = a.props? this.props.concat (a.props): this.props, e = new x.Evénement (s), t = r.longueur; tant que (t -) n = r [t], e [n] = s [n]; retourne e.target || (e.target = o) , 3 === e.target.nodeType && (e.target = e.target.parentNode), a.filter? A.filter (e, s): e}, spécial: {load: {noBubble:! 0}, focus: {trigger: function () {return this! == V () && this.focus? (this.focus (),! 1): undefined}, delegateType: "focusin"}, flou: {trigger: function () {return this === V () && this.blur? (this.blur (),! 1): undefined}, delegateType: "focusout"}, cliquez sur: {trigger: function () {return "checkbox" === this.type && this.click && x.nodeName (this,"input")? (this.click (),! 1): undefined}, _ default: function (e) {return x.nodeName (e.target, "a")}}, beforeunload: {postDispatch: function (e ) {e.result! == undefined && (e.originalEvent.returnValue = e.result)}}}, simuler: fonction (e, t, n, r) {var i = x.extend (nouveau x.Evénement, n , {type: e, isSimulated:! 0, originalEvent: {}}); r? x.event.trigger (i, null, t): x.event.dispatch.call (t, i), i.isDefaultPrevented ( ) && n.preventDefault ()}}, x.removeEvent = fonction (e, t, n) {e.removeEventListener && e.removeEventListener (t, n,! 1)}, x.Event = fonction (e, t) {retourne ceci instanceof x.Event? (e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.getPreventDefault && e.getPreventDefault ()? U: Y:: this.type = e, t && x.extend (this, t), this.timeStamp = e && e.timeStamp || x.now (), this [x.expando] =! 0, non défini): new x.Evénement (e, t)}, x.Event.prototype = {isDefaultPrevented: Y, isPropagationStopped: Y, isImmediatePropagationStopped: Y, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = U, e && e.preventDefault && e. preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = U, e && e.stopPropagation &&..StopPropagation ()}, stopImmediatePropagation: function () {this.isImmediatePropagationStopped = U, que }}, x.each ({mouseenter: "mouseover", mouseleave: "mouseout"}, fonction (e, t) {x.event.special [e] = {delegateType: t, bindType: t, handle: fonction ( e) {var n, r = this, i = e.relatedTarget, o = e.handleObj; return (! i || i! == r &&! x.contains (r, i)) && (e.type = o .origType, n = o.handler.apply (this, arguments), e.type = t), n}}}), x.support.focusinBubbles || x.each ({focus: "focusin",flou: "focusout"}, fonction (e, t) {var n = 0, r = fonction (e) {x.event.simulate (t, e.target, x.event.fix (e) ,! 0) }; x.event.special [t] = {setup: function () {0 === n ++ && o.addEventListener (e, r,! 0)}, démontage: function () {0 === - n && o.removeEventListener (e, r,! 0)}}}), x.fn.extend ({on: fonction (e, t, n, r, i) {var o, s; if ("objet" == typeof e) {"chaîne"! = typeof t && (n = n || t, t = indéfini); pour (s dans e) ceci.on (s, t, n, e [s], i); retourne ceci } if (null == n && null == r? (r = t, n = t = indéfini): null == r && ("chaîne" == typeof t? (r = n, n = indéfini) :( r = n , n = t, t = non défini)), r ===! 1) rextend ({on: fonction (e, t, n, r, i) {var o, s; if ("objet" == typeof e) {"chaîne"! = typeof t && (n = n || t, t = non défini); pour (s dans e) ceci.on (s, t, n, e [s], i); retourne ceci} if (null == n && null == r? (r = t, n = t = non défini): null == r && ("chaîne" == typede t? (r = n, n = non défini) :( r = n, n = t, t = non défini)), r ===! 1) rextend ({on: fonction (e, t, n, r, i) {var o, s; if ("objet" == typeof e) {"chaîne"! = typeof t && (n = n || t, t = non défini); pour (s dans e) ceci.on (s, t, n, e [s], i); retourne ceci} if (null == n && null == r? (r = t, n = t = non défini): null == r && ("chaîne" == typede t? (r = n, n = non défini) :( r = n, n = t, t = non défini)), r ===! 1) r= Y; sinon si (! R) retourne ceci; retourne 1 === i && (o = r, r = fonction (e) {return x (). Off (e), o.apply (this, arguments)}, r.guid = o.guid || (o.guid = x.guid ++)), this.each (function () {x.event.add (this, e, r, n, t)})}, un: fonction (e, t, n, r) {retourne ceci.on (e, t, n, r, 1)}, off: fonction (e, t, n) {var r, i; si (e && e.preventDefault && e. handleObj) renvoie r = e.handleObj, x (e.delegateTarget) .off (r.nomspace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ( "objet" == typede e) {pour (i dans e) ceci.off (i, t, e [i]); retourne cette} retour (t ===! 1 || "fonction" == typeof t) && (n = t, t = non défini), n ===! 1 && (n = Y), this.each (function () {x.event.remove (this, e, n, t)})}, déclencheur : function (e, t) {retourne this.each (function () {x.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; retourne n? x.event.trigger (e, t, n,! 0): non défini}}); var G = / ^. [^:# \ [\.,] * $ /, J = / ^ (?: parents | prev (?: Jusqu'à | tous)) /, Q = x.expr.match.needsContext, K = {enfants:! 0, contenu :! 0, next:! 0, prev:! 0}; x.fn.extend ({find: function (e) {var t, n = [], r = ceci, i = r.longueur; if (" string "! = typeof e) retourne this.pushStack (x (e) .filter (fonction () {pour (t = 0; i> t; t ++) si (x.contains (r [t], this)) return ! 0})); pour (t = 0; i> t; t ++) x.find (e, r [t], n); retourne n = this.pushStack (i> 1? X.unique (n): n), n.selector = this.selector? this.selector + "" + e: e, n}, a: fonction (e) {var t = x (e, ceci), n = t.longueur; retourne ceci. filter (function () {var e = 0; for (; n> e; e ++) if (x.contains (this, t [e])) return! 0})}, pas: function (e) {retourne ceci .pushStack (et (this, e || [],! 0))}, filtre: fonction (e) {retourne this.pushStack (et (this, e || [!,! 1))}, est: fonction (e) {return !! et (this, "chaîne" == typede e && Q.test (e)? x (e): e || [],! 1) .length}, plus proche: fonction (e, t) {var n, r = 0, i = this.longueur, o = [],s = Q.test (e) || "chaîne"! = type de e? x (e, t || ce.context): 0; pour (; i> r; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (11> n.nodeType && (s? s.index (n)> - 1: 1 === n.nodeType && x.find.matchesSelector (n, e)) {n = o.push (n); break} renvoie this.pushStack (o.length> 1? x.unique (o): o)}, index: fonction (e) {retour e? "chaîne" == typeof e? g.call (x (e), this [0]): g.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first ( ) .prevAll (). length: -1}, add: function (e, t) {var n = "chaîne" == typede e? x (e, t): x.makeArray (e && e.nodeType? [e] : e), r = x.merge (this.get (), n); retourne ceci.pushStack (x.unique (r))}, addBack: fonction (e) {retourne ceci.add (null == e? this.prevObject: this.prevObject.filter (e))}}; fonction Z (e, t) {while ((e = e [t]) && 1! == e.nodeType); retourne e} x.each ({parent: function (e) {var t = e.parentNode; retourne t && 11!== t.nodeType? t: null}, parents: fonction (e) {return x.dir (e, "parentNode")}, parentsUntil: fonction (e, t, n) {return x.dir (e, " parentNode ", n)}, next: fonction (e) {return Z (e," nextSibling ")}, prev: fonction (e) {return Z (e," previousSibling ")}, nextAll: function (e) { return x.dir (e, "nextSibling")}, prevAll: fonction (e) {return x.dir (e, "previousSibling")}, nextUntil: function (e, t, n) {return x.dir (e , "nextSibling", n)}, prevUntil: function (e, t, n) {return x.dir (e, "previousSibling", n)}, frères et soeurs: function (e) {return x.sibling ((e. parentNode || {}). firstChild, e)}, enfants: fonction (e) {return x.sibling (e.firstChild)}, contenu: function (e) {return e.contentDocument || x.merge ([] , e.childNodes)}}, function (e, t) {x.fn [e] = fonction (n, r) {var i = x.map (this, t, n); retourne "jusqu'à"! == e.slice (-5) && (r = n), r && "chaîne "== typede r && (i = filtre de x (r, i)), this.length> 1 && (K [e] || x.unique (i), J.test (e) && i.reverse ()) , this.pushStack (i)}}, x.extend ({filtre: fonction (e, t, n) {var r = t [0]; retourne n && (e = ": not (" + e + ")" ), 1 === t.length && 1 === r.nodeType? X.find.matchesSelector (r, e)? [R]: []: x.find.matches (e, x.grep (t, fonction ( e) {return 1 === e.nodeType}))}, dir: function (e, t, n) {var r = [], i = n! == non défini; while ((e = e [t] ) && 9! == e.nodeType) if (1 === e.nodeType) {if (i && x (e) .is (n)) break; r.push (e)} renvoie r}, frère: fonction (e , t) {var n = []; pour (; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); renvoyer n}}); fonction et (e, t , n) {si (x.isFunction (t)) renvoie x.grep (e, fonction (e, r) {retour !! t.call (e, r, e)! == n}); si (t .nodeType) renvoie x.grep (e, fonction (e) {retour e === t! == n}); if ("chaîne" == typeof t) {if (G.test (t)) retourne x.filter (t, e, n); t = x.filtre (t, e)} retourne x.grep (e, fonction (e) {retourne g.call (t, e)> = 0! == n})} var tt = / <(?! Zone | br | col | incorporer | hr | img | entrée | lien | meta | param) (([\ w:] +) [^>] *) \ /> / gi, nt = / <([\ w:] +) /, rt = / <| & #? \ w +; /, it = / <(?: script | style | lien) / i , ot = / ^ (?: case à cocher | radio) $ / i, st = / vérifié \ s * (?: [^ =] | = \ s *. cochée.) / i, at = / ^ $ | \ / (?: java | ecma) script / i, ut = / ^ vrai \ / (. *) /, lt = / ^ \ s * <! (?: \: \ [CDATA \ [| -) | (?: \ ] \] | -)> \ s * $ / g, ct = {option: [1, "<select multiple = 'multiple'>", "</ select>"], thead: [1, "<table > "," </ table> "], col: [2," <table> <colgroup> "," </ colgroup> </ table> "], tr: [2," <table> <tbody> " , "</ tbody> </ table>"], td: [3, "<table> <tbody> <tr>", "</ tr> </tbody></table>"],_default:[0,"","" transférent-vous donc ?,ct.optgroup=ct.option,ct.tbody=ct.tfoot=ct.colgroup=ct.caption=ct.thead , ct.th = ct.td, x.fn.extend ({texte: fonction (e) {retour x.access (ceci, fonction (e) {retour e === non défini? x.text (ceci): ceci .empty (). append ((this [0] && this [0] .ownerDocument || o) .createTextNode (e))}, null, e, arguments.length)}, append: function () {retour this.domManip (arguments, fonction (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = pt (ceci, e); t.appendChild (e)}})}, prepend: function () {return this.domManip (arguments, function (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = pt (this, e); t.insertBefore (e, t.firstChild)}})}, before: function () {retourne this.domManip (arguments, fonction (e) {this. parentNode && this.parentNode.insertBefore (e, this)})}, après: function () {renvoie ceci.domManip (arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, remove: function (e, t) {var n, r = e? x.filter (e, this ): this, i = 0; for (; null! = (n = r [i]); i ++) t || 1! == n.nodeType || x.cleanData (mt (n)), n.parentNode && (t && x.contains (n.ownerDocument, n) && dt (mt (n, "script")), n.parentNode.removeChild (n)); renvoie this}, empty: function () {var e, t = 0; for (; null! = (e = this [t]); t ++) 1 === e.nodeType && (x.cleanData (mt (e,! 1)), e.textContent = ""); retourne ceci}, clone: ​​function (e, t) {return e = null == e?! 1: e, t = null == t? e: t, this.map (function () {return x.clone (this, e, t)}}, html: function (e) {return x.access (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (e === undefined && 1 === t.nodeType) retourne t.innerHTML; if ("chaîne" == typede e &&! it.test (e) &&! ct [(nt.exec (e) || [| ","""]) [1] .toLowerCase ()]) {e = e.replace (tt, "<$ 1> </ $ 2>"); try {pour (; r> n; n ++) t = this [n] || {}, 1 === t.nodeType && (x.cleanData (mt (t,! 1)), t.innerHTML = e); t = 0} attrapez (i) {}} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var e = x.map (this, function (e) {return [e.nextSibling, e.parentNode]}), t = 0; return this.domManip (arguments, fonction (n) {var r = e [t ++], i = e [t ++]; i && (r && r.parentNode! == i && (r = this.nextSibling), x (this ) .remove (), i.insertBefore (n, r))},! 0), t? this: this.remove ()}, detach: function (e) {retour this.remove (e,! 0)} , domManip: fonction (e, t, n) {e = f.apply ([], e); varr, i, o, s, a, u, l = 0, c = ceci.longueur, p = ceci , h = c-1, d = e [0], g = x.isFunction (d); if (g ||! (1> = c || "chaîne"! = typeof d || x.support.checkClone ) && st.test (d)) renvoie this.each (fonction (r) {var i = p.eq (r); g && (e [0] = d.call (this, r, i.html ())), i.domManip (e, t, n)}); if (c && (r = x.buildFragment (e, this [0] .ownDocument,! 1 ,!)! n && this), i = r.firstChild, 1 === r.childNodes.length && (r = i), i)) {pour (o = x.map (mt (r, "script"), ft), s = o.length; c> l; l ++) a = r, l! == h && (a = x.clone (a,! 0,! 0), s && x.merge (o, mt (a, "script")) ), t.call (this [l], a, l); if (s) pour (u = o [longueur.a.] .ownerDocument, x.map (o, ht), l = 0; s> l; l ++) a = o [l], at.test (a.type || "") &&! q.access (a, "globalEval") && x.contains (u, a) && (a.src? x ._evalUrl (a.src): x.globalEval (a.textContent.replace (lt, "")))} renvoie ceci}}), x.each ({appendTo: "append", prependTo: "prepend", insertBefore : "avant", insertAfter: "après", replaceAll: "replaceWith"}, fonction (e, t) {x.fn [e] = fonction (e) {var n, r = [], i = x (e ), o = i.longueur 1, s = 0;pour (; o> = s; s ++) n = s === o? ceci: this.clone (! 0), x (i [s]) [t] (n), h.apply (r, n. get ()); retourne this.pushStack (})}), x.extend ({clone: ​​function (e, t, n) {var r, i, o, s, a = e.cloneNode (! 0) , u = x.contains (e.ownerDocument, e); if (! (x.support.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || x.isXMLDoc (e))) pour ( s = mt (a), o = mt (e), r = 0, i = longueur.i> r; r ++) yt (o [r], s [r]); si (t) si (n ) pour (o = o || mt (e), s = s || mt (a), r = 0, i = longueur.i> r; r ++) gt (o [r], s [r] ); sinon gt (e, a); retourne s = mt (a, "script"), s.longueur> 0 && dt (s,! u && mt (e, "script")), a}, buildFragment: function (e, t, n, r) {var i, o, s, a, u, l, c = 0, p = longueur.e, f = t.createDocumentFragment (), h = []; pour (; p> c; c ++) if (i = e [c], i || 0 === i) if ("objet" === x.type (i)) x.merge (h, i.nodeType? [i]: i ); sinon si (rt.test (i)) {o = o || f.appendChild (t.createElement ("div")), s = (nt.exec (i) || ["", ""] )[1].toLowerCase (), a = ct [s] || ct._default, o.innerHTML = a [1] + i.replace (tt, "<$ 1> </ $ 2>") + a [2], l = a [0]; while (l -) o = o.lastChild; x.merge (h, o.childNodes), o = f.firstChild, o.textContent = ""} autre h.push (t.createTextNode (i )); f.textContent = "", c = 0; tandis que (i = h [c ++]) if ((! r || -1 === x.inArray (i, r)) && (u = x. contient (i.ownerDocument, i), o = mt (f.appendChild (i), "script"), u && dt (o), n)) {l = 0; while (i = o [l ++]) à.test (i.type || "") && n.push (i)} renvoyer f}, cleanData: fonction (e) {var t, n, r, i, o, s, a = x.event.special, u = 0; pour (; (n = e [u])! == non défini; u ++) {if (F.accepts (n) && (o = n [q.expando], o && (t = q.cache [o] ))) {if (r = Object.keys (t.events || {}), r.length) pour (s = 0; (i = r [s])! == non défini; s ++) a [i] ? x.event.remove (n, i): x.removeEvent (n, i, t.handle); q.cache [o] && delete q.cache [o]} supprimer L.cache [n [L.expando] ]}}, _ evalUrl:function (e) {return x.ajax ({url: e, type: "GET", dataType: "script", async: 1, global:! 1, "jette":! 0})}}); pt (e, t) {retourne x.nodeName (e, "table") && x.nodeName (1 === t.nodeType? t: t.firstChild, "tr")? e.getElementsByTagName ("tbody") [ 0] || e.appendChild (e.ownerDocument.createElement ("tbody")): e} fonction ft (e) {return e.type = (null! == e.getAttribute ("type")) + "/ "+ e.type, e} fonction ht (e) {var t = ut.exec (e.type); retourne t? e.type = t [1]: e.removeAttribute (" type "), e} fonction dt (e, t) {var n = longueur.e, r = 0; pour (; n> r; r ++) q.set (e [r], "globalEval",! t || q.get (t [ r], "globalEval"))} fonction gt (e, t) {var n, r, i, o, s, a, u, l; if (1 === t.nodeType) {if (q.hasData (e) && (o = q.accès (e), s = q.set (t, o), l = o.events)) {delete s.handle, s.events = {}; pour (i dans l ) pour (n = 0, r = l [i].longueur; r> n; n ++) x.événement.add (t, i, l [i] [n])} L.hasData (e) && (a = L.access (e), u = x.extend ( {}, a), L.set (t, u))}} fonction mt (e, t) {var n = e.getElementsByTagName? e.getElementsByTagName (t || "*"): e.querySelectorAll? e. querySelectorAll (t || "*"): []; retourne t === non défini || t && x.nodeName (e, t)? x.merge ([e], n): n} fonction yt (e, t) {var n = nom.noeud.toLowerCase (); "entrée" === n && ot.test (type))? t.checked = e.checked :( "entrée" === n || "texte" == = n) && (t.defaultValue = e.defaultValue)} x.fn.extend ({wrapAll: fonction (e) {var t; retour x.isFonction (e)? this (chaque fonction (t) {x ( this) .wrapAll (e.call (this, t))}) :( this [0] && (t = x (e, this [0] .ownDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; retourne e}).append (this)), this)}, wrapInner: function (e) {return x.isFunction (e)? this.each (fonction (t) {x (this) .wrapInner (e.call (this, t)) }): this.each (function () {var t = x (this), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap: function (e) {var t = x.isFunction (e); retourne this.each (fonction (n) {x (this) .wrapAll (t? e.call (this, n): e)})}, annule : function () {renvoie this.parent (). each (function () {x.NodeName (this, "body") || x (this) .replaceWith (this.childNodes)}). end ()}}) ; var vt, xt, bt = / ^ (aucun | table (?! - c [ea]). +) /, wt = / ^ marge /, Tt = RegExp ("^ (" + b + ") (. * ) $ "," i "), Ct = RegExp (" ^ ("+ b +") (?! px) [az%] + $ "," i "), kt = RegExp (" ^ ([+ -] ) = ("+ b +") "," i "), Nt = {BODY:" block "}, Et = {position:" absolute ", visibilité:" hidden ", display:" block "}, St = { letterSpacing: 0, fontWeight: 400},jt = ["Haut", "Droite", "Bas", "Gauche"], Dt = ["Webkit", "O", "Moz", "ms"]; fonction At (e, t) {if ( t dans e) retourne t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = Dt.longueur; tandis que (i -) if (t = Dt [ i] + n, t dans e) retourne t; retourne r} fonction Lt (e, t) {retourne e = t || e, "none" === x.css (e, "display") ||! x.contains (e.ownerDocument, e)} fonction qt (t) {retour e.getComputedStyle (t, null)} fonction Ht (e, t) {var n, r, i, o = [], s = 0 , a = e.length; pour (; a> s; ++) r = e [s], r.style && (o [s] = q.get (r, "olddisplay"), n = r.style.display , t? (o [s] || "none"! == n || (r.style.display = ""), "" === r.style.display && Lt (r) && (o [s] = q.access (r, "olddisplay", Rt (r.nodeName)))): o [s] || (i = Lt (r), (n && "none"! == n ||! i) && q. set (r, "olddisplay",i? n: x.css (r, "display")))); for (s = 0; a> s; ++) r = e [s], r.style && (t && "none"! == r. style.display && ""! == r.style.display || (r.style.display = t? o [s] || "": "none")); retourne e} x.fn.extend ({css : fonction (e, t) {retourne x.access (this, fonction (e, t, n) {varre, i, o = {}, s = 0; if (x.isArray (t)) {pour ( r = qt (e), i = t.longueur; i> s; s ++) o [t [s]] = x.css (e, t [s],! 1, r); retour o} retour n! == non défini? x.style (e, t, n): x.css (e, t)}, e, t, arguments.length> 1)}, show: function () {return Ht (this,! 0 )}, cache: fonction () {return Ht (this)}, bascule: function (e) {retourne "booléen" == type de e? e? this.show (): this.hide (): this.each ( function () {Lt (this)? x (this) .show (): x (this) .hide ()}}}), x.extend ({cssHooks: {opacité: {get: fonction (e, t ) {if (t) {var n = vt (e, "opacity"); return "" === n? "1": n}}}}, cssNumber: {columnCount:! 0,fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacité:! 0, ordre:! 0, orphelin:! 0, veuve:! 0, zIndex:! 0, zoom:! 0}, cssProps: {" float ":" cssFloat "}, style: function (e, t, n, r) {si (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, s, a = x .camelCase (t), u = e.style; retourne t = x.cssProps [a] || (x.cssProps [a] = At ​​(u, a)), s = x.cssHooks [t] || x .cssHooks [a], n === undefined? s && "get" dans s && (i = s.get (e,! 1, r))! == undefined? i: u [t] :( o = typeof n , "chaîne" === o && (i = kt.exec (n)) && (n = (i [1] +1) * i [2] + parseFloat (x.css (e, t)), o = "nombre"), null == n || "nombre" === o && isNaN (n) || ("nombre"! == o || x.cssNumber [a] || (n + = "px"), x .support.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || (u [t] = "inherit"), s && "set" dans s && (n = s. ensemble (e,n, r) === indéfini || (u [t] = n)) indéfini}}, css: fonction (e, t, n, r) {var i, o, s, a = x. camelCase (t); retourne t = x.cssProps [a] || (x.cssProps [a] = At ​​(style.a)), s = x.cssHooks [t] || x.cssHooks [a] , s && "get" dans s && (i = s.get (e,! 0, n)), i === non défini && (i = vt (e, t, r)), "normal" === i && t dans St && (i = St [t]), "" === n || n? (o = analyseFloat (i), n ===! 0 || x.isNumeric (o)? o || 0: i): i}}), vt = fonction (e, t, n) {var r, i, o, s = n || qt (e), a = s? s.getPropertyValue (t) || s [t]: undefined, u = e.style; renvoyer s && (""! == a || x.contains (e.ownerDocument, e) || (a = x.style (e, t)), Ct.test (a) && wt.test (t) && (r = largeur u, i = u.minWidth, o = u.maxWidth, u.minWidth = u.maxWidth = u.width = a, a = s.width, u.width = r, u.minWidth = i, u.maxWidth = o)), a}; fonction Ot (e, t, n) {var r = Tt.exec (t); retourne r? Math.max (0, r [ 1] - (n || 0)) + (r [2] || "px"): t} fonction Ft (e, t, n, r,i) {var o = n === (r? "frontière": "contenu")? 4: "largeur" ​​=== t? 1: 0, s = 0; pour (; 4> o; o + = 2 ) "marge" === n && (s + = x.css (e, n + jt [o],! 0, i)), r? ("contenu" === n && (s- = x.css (e , "remplissage" + jt [o],! 0, i)), "marge"! == n && (s- = x.css (e, "bordure" + jt [o] + "largeur",! 0, i)):: s + = x.css (e, "remplissage" + jt [o],! 0, i), "remplissage"! == n && (s + = x.css (e, "bordure" + jt [o] + "Largeur",! 0, i))); retourne la fonction} Pt (e, t, n) {var r =! 0, i = "largeur" ​​=== t? e.offsetWidth: e .offsetHeight, o = qt (e), s = x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, o); if (0> = i || null == i) {si (i = vt (e, t, o), (0> i || null == i) && (i = e.style [t]), Ct.test (i)) renvoie i ; r = s && (x.support.boxSizingReliable || i === e.style [t]), i = parseFloat (i) || 0} renvoie i + Ft (e,t, n || (s? "frontière": "contenu"), r, o) + "px"} fonction Rt (e) {var t = o, n = Nt [e]; retourne n || (n = Mt (e, t), "none"! == n && n || (xt = (xt || x ("<iframe frameborder =" 0 ") =" 0 "width =" 0 "/>"). Css ("cssText", "display: block! important")). appendTo (t.documentElement), t = (xt [0] .contentWindow || xt [0] .contentDocument) .document, t.write ("<! doctype html> <html> <body> "), t.close (), n = Mt (e, t), xt.detach ()), Nt [e] = n), n} fonction Mt (e, t ) {var n = x (t.createElement (e)). appendTo (t.body), r = x.css (n [0], "display"); retourne n.remove (), r} x.each (["hauteur", "largeur"], fonction (e, t) {x.cssHooks [t] = {get: fonction (e, n, r) {return n? 0 === e.offsetWidth && bt.test ( x.css (e, "display"))? x.swap (e, Et, fonction () {return Pt (e, t, r)}): Pt (e, t, r): non défini},ensemble: fonction (e, n, r) {var i = r && qt (e); retourne Ot (e, n, r? Ft (e, t, r, x.support.boxSizing && "border-box" === x .css (e, "boxSizing",! 1, i), i): 0)}}}), x (fonction () {x.support.reliableMarginRight || (x.cssHooks.marginRight = {get: function ( e, t) {return t? x.swap (e, {display: "inline-block"}, vt, [e, "marginRight"]): undefined}},! x.support.pixelPosition && x.fn.position && x .each (["top", "left"], fonction (e, t) {x.cssHooks [t] = {obtenir: fonction (e, n) {retourne n? (n = vt (e, t), Ct.test (n)? X (e) .position () [t] + "px": undefined}}})}), x.expr && x.expr.filters && (x.expr.filters.hidden = fonction (e) {return 0> = e.offsetWidth && 0> = e.offsetHeight}, x.expr.filters.visible = fonction (e) {return! x.expr.filters.hidden (e)}), x.each ({margin: "", padding: "", border: "Width"},fonction (e, t) {x.cssHooks [e + t] = {développer: fonction (n) {var r = 0, i = {}, o = "chaîne" == typede n? n.split ("" ): [n]; pour (; 4> r; r ++) i [e + jt [r] + t] = o [r] || o [r-2] || o [0]; retour i}} wt.test (e) || (x.cssHooks [e + t] .set = Ot)}); var Wt = /% 20 / g, $ t = / \ [\] $ /, Bt = / \ r? \ n / g, It = / ^ (?: soumettre | bouton | image | réinitialiser | fichier) $ / i, zt = / ^ (?: entrée | sélectionner | texte | clé |) /i;x.fn. extend ({serialize: function () {return x.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = x.prop (this, "éléments") ; return e? x.makeArray (e): this}). filter (function () {var e = this.type; renvoie this.name &&! x (this) .is (": disabled") && zt.test (this .nodeName) &&! It.test (e) && (this.checked ||! ot.test (e))}). map (fonction (e, t) {var n = x (this) .val (); return null == n? null: x.isArray (n)? x.map (n, fonction (e) {return {nom: t.nom, valeur: e.replace (Bt, "\ r \ n ")}}): {nom: t.nom, valeur: n.replace (Bt," \ r \ n ")}}). get ()}}), x.param = fonction (e , t) {var n, r = [], i = fonction (e, t) {t = x.isFunction (t)? t (): null == t? "": t, r [longueur.r] = encodeURIComponent (e) + "=" + encodeURIComponent (t)}; if (t === undefined && (t = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray (e) || e.jquery &&! x.isPlainObject (e)) x.each (e, function () {i (this.name, this.value)}); sinon pour (n dans e) _t (n, e [n], t, i); retourne r .join ("&"). remplacer (Wt, "+")}; fonction _t (e, t, n, r) {var i; if (x.isArray (t)) x.each (t, fonction ( t, i) {n || $ t.test (e)? r (e, i): _ t (e + "[" + ("objet" == typeof i? t: "") + "]", i , n, r)}); sinon si (n || "objet"! == x.type (t)) r (e, t); sinon pour (i dans t) _t (e + "[" + i + " ] ", t [i], n, r)} x.each ("flou focus focusin focusout charger redimensionner défiler défiler cliquer dblclick mousedown mouseup déplacer souris mouseover déplacer souris mouseover souris mouseleave changer sélectionner envoyer touche bas appuyer sur la touche touche erreur contextmenu ".split (" "), fonction (e, t) {x.fn [t] = fonction (e , n) {return arguments.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend ({survol: fonction (e, t) { renvoyer this.mouseenter (e) .mouseleave (t || e)}, bind: fonction (e, t, n) {renvoyer this.on (e, null, t, n)}, unbind: fonction (e, t ) {retour this.off (e, null, t)mouseleave (t || e)}, bind: fonction (e, t, n) {retourne this.on (e, null, t, n)}, unbind: fonction (e, t) {retourne this.off (e , null, t)mouseleave (t || e)}, bind: fonction (e, t, n) {retourne this.on (e, null, t, n)}, unbind: fonction (e, t) {retourne this.off (e , null, t)
}, délégué: fonction (e, t, n, r) {retourne this.on (t, e, n, r)}, non délégué: fonction (e, t, n) {retourne 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}}); var Xt, Ut, Yt = x.now (), Vt = / \? /, Gt = / #. * $ /, Jt = / ([? &]) _ = [^ &] * /, Qt = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm, Kt = / ^ (?: à propos de | app | app-storage |. + - extension | fichier | res | widget): $ /, Zt = / ^ (?: GET | HEAD) $ /, en = / ^ \ / \ //, tn = / ^ ([\ w. + -] +:) (?: \ / \ / ([^ \ /? #:] *) (?: :( \ d +) |) |) /, nn = x.fn.load, rn = {}, sur = {}, sn = "* /". concat ("*"); essayez {Ut = i.href} catch (an) {Ut = o.createElement ("a"), Ut.href = "", Ut = Ut.href} Xt = tn.exec (Ut.toLowerCase ()) || []; fonction un (e) {fonction de retour (t, n) {"chaîne"! = typede t && (n = t, t = "*"); varr, i = 0, o = t.toLowerCase (). match (w) || [ ]; if (x.isFunction (n)) tandis que (r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [r ] = e [r] || []). unshift (n)):(e [r] = e [r] || []). push (n)}} fonction ln (e, t, n, r) {var i = {}, o = e ===; fonction s (a) {var u; retournez i [a] =! 0, x.each (e [a] || [], fonction (e, a) {var l = a (t, n, r); retour " chaîne "! = typede l || o || i [l]? o?! (u = l): indéfini: (t.dataTypes.unshift (l), s (l),! 1)}, u} renvoyer s (t.dataTypes [0]) ||! i ["*"] && s ("*")} fonction cn (e, t) {var n, r, i = x.ajaxSettings.flatOptions || {} ; pour (n dans t) t [n]! == non défini && ((i [n]? e: r || (r = {})) [n] = t [n]); retourne r && x.extend (! 0, e, r), e} x.fn.load = fonction (e, t, n) {if ("chaîne"! = Typede e && nn) retourne nn.apply (this, arguments); var r, i, o , s = ceci, a = e.indexOf (""); retourne a> = 0 && (r = e.slice (a), e = e.slice (0, a)), x.isFunction (t)? ( n = t, t = non défini): t && "objet" == typede t && (i = "POST"), longueur maximale> 0 && x.ajax ({url: e, type: i, type de données: "html", données: t}).done (fonction (e) {o = arguments, s.html (r? x ("<div>"). append (x.parseHTML (e)). find (r): e)}) complet (n && fonction ( e, t) {s.each (n, o || [e.responseText, t, e])}), this}, x.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError" , "ajaxSuccess", "ajaxSend"], fonction (e, t) {x.fn [t] = fonction (e) {retourne ceci.on (t, e)}}), x.extend ({actif: 0 , lastModified: {}, etag: {}, ajaxSettings: {url: Ut, tapez: "GET", isLocal: Kt.test (Xt [1]), global:! 0, processData:! 0, async:! 0 , contentType: "application / x-www-form-urlencoded; charset = UTF-8", accepte: {"*": sn, texte: "text / plain", html: "text / html", xml: "application / xml, text / xml ", json:" application / json, text / javascript "}, contenu: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml:" responseXML ",text: "responseText", json: "responseJSON"}, convertisseurs: {"* text": String, "text html":! 0, "text json": x.parseJSON, "text xml": x.parseXML}, flatOptions: {url:! 0, contexte:! 0}}, ajaxSetup: fonction (e, t) {retourne t? cn (cn (e, x.ajaxSettings), t): cn (x.ajaxSettings, e)} , ajaxPrefilter: un (rn), ajaxTransport: un (sur), ajax: fonction (e, t) {"objet" == typede e && (t = e, e = indéfini), t = t || {}; var n, r, i, o, s, a, u, l, c = x.ajaxSetup ({}, t), p = c.context || c, f = c.context && (p.nodeType || p. jquery)? x (p): x.événement, h = x.Deferred (), d = x.Callbacks ("une fois en mémoire"), g = c.statusCode || {}, m = {}, y = { }, v = 0, b = "annulé", T = {readyState: 0, getResponseHeader: fonction (e) {var t; if (2 === v) {si (! o) {o = {}; tant que (t = Qt.exec (i)) o [t [1] .toLowerCase ()] = t [2]} t = o [e.toLowerCase ()]} return null == t? null: t}, getAllResponseHeaders :function () {return 2 === v? i: null}, setRequestHeader: function (e, t) {var n = e.toLowerCase (); retourne v || (e = y [n] = y [n] || e, m [e] = t), ceci}, overrideMimeType: fonction (e) {retour v || (c.mimeType = e), ceci}, code d'état: fonction (e) {var t; if (e ) si (2> v) pour (t dans e) g [t] = [g [t], e [t]]; sinon T. toujours (e [T.status]); renvoyer ceci}, annuler: fonction (e) {var t = e || b; retourne n && n.abort (t), k (0, t), ceci}}; if (h.promise (T) .complete = d.add, T.success = T.done, T.error = T.fail, c.url = ((e || c.url || Ut) + ""). Replace (Gt, ""). Replace (en, Xt [1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = x.trim (c.dataType || "*"). toLowerCase () .match (w) || [""], null == c.crossDomain && (a = tn.exec (c.url.toLowerCase ()), c.crossDomain =! (! a || a [1] == = Xt [1] && a [2] === Xt [2] && (a [3] || ("http:" === a [1]? "80": "443")) === (Xt [3] || ("http:" === Xt [1]? "80": "443"))), c.data && c.processData && "chaîne"! = Typeof c. data && (c.data = x.param (c.data, c.traditional)), ln (rn, c, t, T), 2 === v) retourne T; u = c.global, u && 0 === x.active ++ && x.event.trigger ("ajaxStart"), c.type = c.type.toUpperCase (), c.hasContent =! Zt.test (c.type), r = c.url, c. hasContent || (c.data && (r = c.url + = (Vt.test (r)? "&": "?") + c.data, supprimez c.data), c.cache ===! 1 && ( c.url = Jt.test (r)? r.replace (Jt, "$ 1 _ =" + Yt ++): r + (Vt.test (r)? "&": "?") + "_ =" + Yt ++ )), c.ifModified && (x.lastModified [r] && T.setRequestHeader ("If-Modified-Since", x.lastModified [r]), x.etag [r] && T.setRequestHeader ("If-None-Match" , x.etag [r])), (c.data && c.hasContent && c.contentType! ==! 1 || t.contentType) && T.setRequestHeader ("Content-Type", c.contentType), T.setRequestHeader ("Accepter", c.dataTypes [0] && c.accepts [c.dataTypes [0]]? C.accepts [c.dataTypes [0]] + ("*"! == c.dataTypes [0]? "," + Sn + "; q = 0.01": ""): c.accepts ["*"]); for (l dans c.headers) T.setRequestHeader (l, c.headers [l]); if (c.beforeSend && (c.beforeSend.call (p, T, c) === ! 1 || 2 === v)) renvoie T.abort (); b = "avorter"; pour (l dans {succès: 1, erreur: 1, complet: 1}) T [l] (c [l ]); if (n = ln (sur, c, t, T)) {T.readyState = 1, u && f.trigger ("ajaxSend", [T, c]), c.async && c.timeout> 0 && (s = setTimeout (function () {T.abort ("timeout")}, c.timeout)); essayez {v = 1, n.send (m, k)} attrapez (C) {if (! (2> v) ) jette C; k (-1, C)}} sinon k (-1, "Pas de transport"); fonction k (e, t, o, a) {var l, m, y, b, w,C = t; 2! == v && (v = 2, s && clearTimeout (s), n = non défini, i = a || "", T.readyState = e> 0? 4: 0, l = e> = 200 && 300> e || 304 === e, o && (b = pn (c, T, o)), b = fn (c, b, T, l), l? (c.ifModified && (w = T.getResponseHeader (" Last-Modified "), w && (x.lastModified [r] = w), w = T.getResponseHeader (" etag "), w && (x.etag [r] = w)), 204 === e ||" HEAD "=== c.type? C =" nocontent ": 304 === e? C =" non modifié ":( C = b.state, m = b.data, y = b.error, l =! Y )):: y = C, (e ||! C) && (C = "erreur", 0> e && (e = 0))), T.status = e, T.statusText = (t || C) + "", l? h.resolveWith (p, [m, C, T]): h.rejectWith (p, [T, C, y]), T.statusCode (g), g = non défini, u && f.trigger (l? "ajaxSuccess": "ajaxError", [T, c, l: m: y]), d.fireWith (p, [T, C]), u && (f.trigger ("ajaxComplete", [T, c]), - x.active || x.event.trigger ("ajaxStop")))} retourne T}, getJSON: fonction (e, t, n) {retourne x.get (e, t, n, "json")}, getScript: fonction (e, t) { renvoyer x.get (e, indéfini, t, "script")}}), x.each (["obtenir", "post"], fonction (e, t) {x [t] = fonction (e, n , r, i) {retour x.isFunction (n) && (i = i || r, r = n, n = indéfini), x.ajax ({url: e, type: t, dataType: i, data: n, succès: r})}}); fonction pn (e, t, n) {var r, i, o, s, a = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), r === non défini && (r = e.mimeType || t.getResponseHeader ("Content-Type")); if (r) pour (i dans a) if (a [ i] && a [i] .test (r)) {u.unshift (i); pause} if (u [0] en n) o = u [0]; sinon {pour (i en n) {if (! u [0] || e.convertisseurs [i + "" + u [0]]) {o = i; pause} s || (s = i)} o = o || s} retour o? (o! = = u [0] && u.unshift (o), n [o]): non défini} fonction fn (e, t, n, r) {var i, o, s, a, u, l = {}, c = e.dataTypes.slice (); if (c [1]) pour (s dans e.convertisseurs) l [s.toLowerCase ()] = e.convertisseurs [s]; o = c.shift (); tant que (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t),! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ("*" === o) o = u; sinon si ("*"! == u && u! == o) {si (s = l [u + "" + o] || l ["*" + o],! s) pour (i dans l) si (a = i.split (""), a [1] === o && (s = l [u + "" + a [0]] || l ["*" + a [0]])) {s === ! 0? S = l [i]: l [i]! ==! 0 && (o = a [0], c.unshift (a [1])); break} if (s! ==! 0) if (s && e ["jette"]) t = s (t); sinon essayez {t = s (t)} catch (p) {return {état: "erreur de syntaxe", erreur: s? p: "Aucune conversion de" + u + "à" + o}}} return {état: "succès", données: t}} x.ajaxSetup ({accepte: {script: "texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript "}, contenu: {script: / (?: java | ecma) script /}, convertisseurs: {"script de texte": fonction (e) {retourne x.globalEval (e), e}}}), x.ajaxPrefilter ( "script", fonction (e) {e.cache === non défini && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), x.ajaxTransport ("script", fonction ( e) {if (e.crossDomain) {var t, n; return {send: function (r, i) {t = x ("<script>"). prop ({async:! 0, jeu de caractères: e.scriptCharset , src: e.url}). on ("erreur de chargement", n = fonction (e) {t.remove (), n = null, e && i ("erreur" === e.type? 404: 200, e .type)}), o.head.appendChild (t [0])}, annulez: function () {n && n ()}}}); var hn = [], dn = / (=) \? (? = & | $) | \? \? /; x.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = hn.pop () || x.expando + "_" + Yt ++; renvoie ceci [e] =! 0, e}}), x.ajaxPrefilter ("json jsonp", fonction (t, n, r) {var i, o, s, a = t.jsonp! ==! 1 && (dn.test (t.url)? "url": "chaîne" == typede t.data &&! (t.contentType || ""). indexOf ("application / x-www-form -urlencoded ") && dn.test (t.data) &&" data "); renvoyer un ||" jsonp "=== t.dataTypes [0]? (i = t.jsonpCallback = x.isFunction (t.jsonpCallback) ? t.jsonpCallback (): t.jsonpCallback, a? t [a] = t [a] .remplace (dn, "$ 1" + i): t.jsonp! ==! 1 && (t.url + = (Vt. test (t.url)? "&": "?") + t.jsonp + "=" + i), t.convertisseurs ["script json"] = fonction () {retour s || x.error (i + " n’a pas été appelé "), s [0]}, t.dataTypes [0] =" json ", o = e [i], e [i] = fonction () {s = arguments}, r.toujours (fonction ( ) {e [i] = o, t [i] && (t.jsonpCallback = n.jsonpCallback, hn.push (i)), s && x.isFunction (o) && o (s [0]), s = o = indéfini }), "script"): non défini}), x.ajaxSettings.xhr = function () {try {return new XMLHttpRequest} catch (e) {}}; var gn = x.ajaxSettings.xhr (), mn = {0: 200,1223: 204}, yn = 0, vn = {}; e.ActiveXObject && x (e) .on ("décharger", function () {pour (var e dans vn) vn [e] (); vn = non défini}), x.support.cors = !! gn && "withCredentials" dans gn, x.support.ajax = gn = !! gn, x.ajaxTransport (fonction (e) {var t; retourne x.support.cors || gn &&! e.crossDomain? {send: function (n , r) {var i, o, s = e.xhr (); if (s.open (type.e, e.url, e.async, e.nom d'utilisateur, e.password), e.xhrFields) pour ( i dans e.xhrFields) s [i] = e.xhrFields [i]; e.mimeType && s.overrideMimeType && s.overrideMimeType (e.mimeType), e.crossDomain || n ["X-Requested-With"] || (n ["X-Requested-With"] = "XMLHttpRequest"); pour (i en n) s.setRequestHeader (i, n [i]); t = fonction (e) {fonction de retour () {t && (delete vn [ o], t = s.onload = s.onerror = null, "abort "=== e? s.abort ():" erreur "=== e? r (état.Stat || 404, état.Tat.ext): r (mn [état.Stat] || état, s .statusText, "string" == type of s.responseText? {text: s.responseText}: indéfini, s.getAllResponseHeaders ()))}}, s.onload = t (), s.onerror = t ("erreur" ), t = vn [o = yn ++] = t ("abort"), s.send (e.hasContent && e.data || null)}, abort: function () {t && t ()}: undefined}); var xn, bn, wn = / ^ (?: basculer | afficher | masquer) $ /, Tn = RegExp ("^ (?: ([+ -]) = |) (" + b + ") ([az%] * ) $ "," i "), Cn = / queueHooks $ /, kn = [An], Nn = {" * ": [fonction (e, t) {var n = ce.createTween (e, t), r = n.cur (), i = Tn.exec (t), o = i && i [3] || (x.cssNumber [e]? "": "px"), s = (x.cssNumber [e] | | "px"! == o && + r) && Tn.exec (x.css (n.elem, e)), a = 1, u = 20; si (s && s [3]! == o) {o = o || s [3], i = i || [], s = + r || 1; faites a = a || ".5", s / = a, x.style (n.elem, e, s + o); while (a! == (a = n.cur () / r) && 1! == a && - u)} renvoie i && (s = n.start = + s || + r || 0, n.unité = o, n.end = i [1]? s + (i [1] +1) * i [2]: + i [2]), n}]}; fonction En ( ) {return setTimeout (function () {xn = non défini}), xn = x.now ()} fonction Sn (e, t, n) {varr, i = (Nn [t] || []). concat (Nn ["*"]), o = 0, s = longueur i; pour (; s> o; o ++) si (r = i [o] .call (n, t, e)) renvoie r} fonction jn (e, t, n) {varr, i, o = 0, s = longueur.no, a = x.Deferred (). always (fonction () {delete u.elem}), u = fonction () {si (i) renvoie! 1; var t = xn || En (), n = Math.max (0, l.startTime + l.duration-t), r = n / l.duration || 0, o = 1-r, s = 0, u = l.tweens.longueur; pour (; u> s; s ++) l.tweens [s] .run (o); retourne un.notifyWith (e, [l, o, n]), 1> o && u? n: (a.resolveWith (e, [l]),! 1)}, l = a.promise ({elem: e, props: x.extend ({}, t), opts: x.extend (! 0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, heure de début: xn || En (), durée: n.duration, tweens: [], createTween:fonction (t, n) {var r = x.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing); retourne l.tweens.push (r) , r}, stop: function (t) {var n = 0, r = t? l.tweens.length: 0; si (i) renvoie ceci; pour (i =! 0; r> n; n ++) l. tweens [n] .run (1); retourne t? a.resolveWith (e, [l, t]): a.rejectWith (e, [l, t]), this}}, c = l.props; pour (Dn (c, l.opts.specialEasing); s> o; o ++) si (r = kn [o] .call (l, e, c, l.opts)) renvoie r; renvoie x.map (c , Sn, l), x.isFunction (l.opts.start) && l.opts.start.call (e, l), x.fx.timer (x.extend (u, {elem: e, anim: l, file: l.opts.queue})), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail). toujours (l. opts.always)} fonction Dn (e, t) {var n, r, i, o, s; pour (n dans e) si (r = x.camelCase (n), i = t [r], o = e [n], x.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, supprimez e [n ]), s = x.cssHooks [r], s && "expand" dans s) {o = s.expand (o), supprimez e [r];pour (n dans o) n dans e || (e [n] = o [n], t [n] = i)} sinon t [r] = i} x.Animation = x.extend (jn, {tweener : fonction (e, t) {x.isFonction (e)? (t = e, e = ["*"]): e = e.split (""); var n, r = 0, i = e. longueur; pour (; i> r; r ++) n = e [r], Nn [n] = Nn [n] || [], Nn [n] .unshift (t)}, préfiltre: fonction (e, t ) {t? kn.unshift (e): kn.push (e)}}); fonction An (e, t, n) {varr, i, o, s, a, u, l = ceci, c = {}, p = style de style, f = type de noeud et & Lt (e), h = q.get (e, "fxshow"); n.queue || (a = x._queueHooks (e, "fx"), null == a.unqueued && (a.unqueued = 0, u = a.empty.fire, a.empty.fire = fonction () {a.unqueued || u ()}, a.unqueued ++, l.always ( function () {l.always (function () {a.unqueued -, x.queue (e, "fx"). length || a.empty.fire ()})), 1 === e .nodeType && ("height" in t || "width" en t) && (n.overflow = [overflow, p.overflowX, p.overflowY], "inline" === x.css (e, "display ") &&"none" === x.css (e, "float") && (p.display = "inline-block")), n.overflow && (p.overflow = "hidden", l.always (function () { p.overflow = n.overflow [0], p.overflowX = n.overflow [1], p.overflowY = n.overflow [2]})); pour (r dans t) if (i = t [r] , wn.exec (i)) {if (efface t [r], o = o || "toggle" === i, i === (f? "hide": "show")) {if (" show "! == i ||! h || h [r] === indéfini) continue; f =! 0} c [r] = h && h [r] || x.style (e, r)} if ( ! x.isEmptyObject (c)) {h? "hidden" dans h && (f = h.hidden): h = q.access (e, "fxshow", {}), o && (h.hidden =! f), f? x (e) .show (): l.done (fonction () {x (e) .hide ()}), l.done (fonction () {var t; q.remove (e, "fxshow" ); pour (t dans c) x.style (e, t, c [t])}); pour (r dans c) s = Sn (f? h [r]: 0, r, l), r dans h || (h [r] = s.start, f && (s.end = s.start, s.start = "width" === r || "height" === r? 1:0))}} fonction Ln (e, t, n, r, i) {retourne un nouveau Ln.prototype.init (e, t, n, r, i)} x.Tween = Ln, Ln.prototype = {constructeur : Ln, init: fonction (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this .start = this.now = this.cur (), this.end = r, this.unit = o || (x.cssNumber [n]? "": "px")}, cur: function () {var e = Ln.propHooks [this.prop]; retourne e && e.get? e.get (this): Ln.propHooks._default.get (this)}, exécutez: function (e) {var t, n = Ln.propHooks [this.prop]; retour this.pos = t = this.options.duration? x.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration): e , this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n. set (this): Ln.propHooks._default.set (this), this}}, Ln.prototype.init.prototype = Ln.prototype, Ln.propHooks = {_ défaut: {get:fonction (e) {var t; retour null == e.elem [e.prop] || e.elem.style && null! = e.elem.style [e.prop]? (t = x.css (e.elem , e.prop, ""), t && "auto"! == t? t: 0): e.elem [e.prop]}, définissez: function (e) {x.fx.step [e.prop] ? x.fx.step [e.prop] (e): e.elem.style && (null! = e.elem.style [x.cssProps [e.prop]] || x.cssHooks [e.prop]) ? x.style (e.elem, e.prop, e.now + e.unit): e.elem [e.prop] = e.now}}}, Ln.propHooks.scrollTop = Ln.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, x.each (["bascule", "show", "masquer" ], fonction (e, t) {var n = x.fn [t]; x.fn [t] = fonction (e, r, i) {retour null == e || "booléen" == typede e? n.apply (this, arguments): this.animate (qn (t,! 0), e, r, i)}}), x.fn.extend ({fadeTo: function (e, t, n, r) {return this.filter (Lt) .css ("opacity", 0) .show (). end (). animate ({opacity:t}, e, n, r)}, animer: fonction (e, t, n, r) {var i = x.isEmptyObject (e), o = x.speed (t, n, r), s = fonction () {var t = jn (this, x.extend ({}, e), o); (i || q.get (this, "finish")) && t.stop (! 0)}; retourne s. finish = s, i || o.queue ===! 1? this.each (s): this.queue (o.queue, s)}, arrêtez: fonction (e, t, n) {var r = fonction (e) {var t = e.stop; supprime e.stop, t (n)}; renvoie "chaîne"! = typede e && (n = t, t = e, e = indéfini), t && e! ==! 1 && this .queue (e || "fx", []), this.each (function () {var t =! 0, i = null! = e && e + "queueHooks", o = x.timers, s = q.get ( si (i) s [i] && s [i] .stop && r (s [i]); else pour (i en s) s [i] && s [i] .stop && Cn.test (i) && r (s [ i]); for (i = o.length; i -;) o [i] .elem! == this || null! = e && [i] .queue! == e || (o [i]. anim.stop (n), t =! 1, o.splice (i, 1)); (t ||! n) && x.dequeue (this, e)})}, terminer: fonction (e) {retour e ! ==! 1 && (e = e || "fx"), this.each (function () {var t, n = q.get (this), r = n [e + "file d'attente"], i = n [e + "queueHooks" ], o = x.timers, s = r? r.length: 0; pour (n.finish =! 0, x.queue (this, e, []), i && i.stop && i.stop.call (this ,! 0), t = o.longueur; t -;) o [t] .elem === ceci && o [t] .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); pour (t = 0; s> t; t ++) r [t] && r [t] .finish && r [t] .finish.call (this); supprimer n.finish})}}); fonction qn (e, t) {var n, r = {hauteur: e}, i = 0; pour (t = t? 1: 0; 4> i; i + = 2-t) n = jt [i], r ["marge" + n] = r ["padding" + n] = e; renvoyer t && (r.opacité = r.width = e), r} x.each ({slideDown: qn ("show"), slideUp: qn ("hide"), slideToggle: qn ("bascule"), fadeIn: {opacité: "show"}, fadeOut: {opacité: "masquer"}, fadeToggle: {opacité: "bascule"}, fonction (e, t) {x.fn [e] = fonction (e, n,r) {retourne this.animate (t, e, n, r)}}), x.speed = fonction (e, t, n) {var r = e && "objet" == typede e? x.extend ({ }, e): {complete: n ||! n && t || x.isFunction (e) && e, durée: e, accélération: n && t || t &&! x.isFunction (t) && t}; renvoyer r.duration = x. fx.off?0:"number"==typeof r.duration? r.duration: r.duration dans x.fx.speeds? x.fx.speeds [r.duration]: x.fx.speeds._default, ( null == r.queue || r.queue ===! 0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {x.isFunction (r. ancien) && r.old.call (this), r.queue && x.dequeue (this, r.queue)}, r}, x.easing = {linéaire: fonction (e) {retour e}, swing: fonction (e) {return.5-Math.cos (e * Math.PI) / 2}}, x.timers = [], x.fx = Ln.prototype.init, x.fx.tick = function () {var e, t = x.timers, n = 0; pour (xn = x.now (); t.longueur> n; n ++) e = t [n], e () || t [n]! == e || t.splice (n -, 1); t.length || x.fx.stop (),xn = non défini}, x.fx.timer = fonction (e) {e () && x.timers.push (e) && x.fx.start ()}, x.fx.interval = 13, x.fx.start = fonction () {bn || (bn = setInterval (x.fx.tick, x.fx.interval))}}, x.fx.stop = fonction () {clearInterval (bn), bn = null}, x.fx .speeds = {lent: 600, rapide: 200, _default: 400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = fonction (e) {return x. grep (x.timers, function (t) {return e === t.elem}). length}), x.fn.offset = function (e) {if (arguments.length) renvoie e === undefined? this: this.each (fonction (t) {x.offset.setOffset (this, e, t)}); var t, n, i = ceci [0], o = {haut: 0, gauche: 0}, s = i && i.ownerDocument; if (s) retourne t = s.documentElement, x.contains (t, i)? (typede i.getBoundingClientRect! == r && (o = i.getBoundingClientRect ()), n = Hn (s ), {top: o.top + n.pageYOffset-t.clientTop, gauche: o.left + n.pageXOffset-t.clientLeft}): o}, x.offset = {setOffset: fonction (e, t,n) {var r, i, o, s, a, u, l, c = x.css (e, "position"), p = x (e), f = {}; "statique" === c && (e.style.position = "relative"), a = p.offset (), o = x.css (e, "haut"), u = x.css (e, "gauche"), l = (" absolue "=== c ||" fixée "=== c) && (o + u) .indexOf (" auto ")> - 1, l? (r = p.position (), s = r.top, i = r.left) :( s = parseFloat (o) || 0, i = parseFloat (u) || 0), x.isFunction (t) && (t = t.call (e, n, a)) , null! = t.top && (f.top = t.top-a.top + s), null! = t.left && (f.left = t.left-a.left + i), "using" dans t ? t.using.call (e, f): p.css (f)}}, x.fn.extend ({position: fonction () {if (this [0]) {var e, t, n = this [0], r = {top: 0, left: 0}; return "fixed" === x.css (n, "position")? T = n.getBoundingClientRect () :( e = this.offsetParent () , t = this.offset (), x.nodeName (e [0], "html") || (r = e.offset ()), r.top + = x.css (e [0], "borderTopWidth ",! 0), r.left + = x.css (e [0]," borderLeftWidth ",! 0)), {top: t.top-r.top-x.css (n," marginTop ", ! 0), à gauche: t.left-r.left-x.css (n, "marginLeft",! 0)}}}, offsetParent: function () {retour this.map (function () {var e = this .offsetParent || s; while (e &&! x.nodeName (e, "html") && "statique" === x.css (e, "position")) e = e.offsetParent; retourne e || s} )}}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (t, n) {var r = "pageYOffset" === n; x.fn [t] = fonction ( i) {retour x.access (this, fonction (t, i, o) {var s = Hn (t); retour o === non défini? s? s [n]: t [i] :( s? s .scrollTo (r.e.pageXOffset: o, r? o: e.pageYOffset): t [i] = o, non défini)}, t, i, arguments.length, null}}); fonction Hn (e) {return x.isWindow (e)? e: 9 === e.nodeType && e.defaultView} x.each ({Hauteur: "hauteur", Largeur: "width "}, fonction (e, t) {x.each ({padding:" inner "+ e, contenu: t," ":" outer "+ e}, fonction (n, r) {x.fn [r ] = fonction (r, i) {var o = arguments.length && (n || "booléen"! = typeof r), s = n || (r ===! 0 || i ===! 0? " margin ":" border "); renvoie x.access (this, fonction (t, n, r) {var i; renvoie x.isWindow (t)? t.document.documentElement [" client "+ e]: 9 = == t.nodeType? (i = t.documentElement, Math.max (t.body ["scroll" + e], i ["scroll" + e], t.body ["offset" + e], i [ "offset" + e], i ["client" + e])): r === non défini? x.css (t, n, s): x.style (t, n, r, s)}, t , o? r: undefined, o, null)}})}), x.fn.size = function () {return this.length}, x.fn.andSelf = x.fn.addBack, "object" == typeof module && module && "objet" == typeof module.exports? module.exports = x: "fonction" == typeof définir && define.amd && define ("jquery", [], fonction () {return x}), "objet" == typede e && "objet" == type de e.document && (e.jQuery = e. $ = x)} la fenêtre);